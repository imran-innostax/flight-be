
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type specialServiceRuleTablePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "specialServiceRuleTable"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    enable: boolean | null
    currency: string | null
    origin: string | null
    destination: string | null
    carriercode: string | null
    offermeals: boolean | null
    offerseats: boolean | null
    Offerfrequentflyermiles: boolean | null
    offerpricewithincludedbaggage: boolean | null
  }, ExtArgs["result"]["specialServiceRuleTable"]>
  composites: {}
}

/**
 * Model specialServiceRuleTable
 * 
 */
export type specialServiceRuleTable = runtime.Types.DefaultSelection<specialServiceRuleTablePayload>
export type locationsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "locations"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    iata: string | null
    cityName: string | null
    airportName: string | null
    country: string | null
    countryCode: string | null
    icon: string | null
  }, ExtArgs["result"]["locations"]>
  composites: {}
}

/**
 * Model locations
 * 
 */
export type locations = runtime.Types.DefaultSelection<locationsPayload>
export type BookingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Booking"
  objects: {
    Passenger: PassengerPayload<ExtArgs>[]
    Itinerary: ItineraryPayload<ExtArgs>[]
    Price: PricePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    orderId: string | null
    orderRef: string | null
    orderType: string | null
    status: string | null
    reference: string | null
    paymentIntentId: string | null
    paymentStatus: string | null
    supplier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeSessionId: string | null
    razorpayOrderId: string | null
    flightOfferId: string | null
    flightInternalSource: string | null
    userEmail: string | null
  }, ExtArgs["result"]["booking"]>
  composites: {}
}

/**
 * Model Booking
 * 
 */
export type Booking = runtime.Types.DefaultSelection<BookingPayload>
export type PassengerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Passenger"
  objects: {
    Booking: BookingPayload<ExtArgs> | null
    Document: DocumentPayload<ExtArgs>[]
    Baggage: BaggagePayload<ExtArgs>[]
    fareDetailsByRoute: fareDetailsByRoutePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    passengerId: string | null
    countryCode: string | null
    email: string | null
    dateOfBirth: string | null
    passengerType: string | null
    title: string | null
    gender: string | null
    firstName: string | null
    lastName: string | null
    seatNumber: string | null
    fareOption: string | null
    bookingId: string | null
    phone: string | null
  }, ExtArgs["result"]["passenger"]>
  composites: {}
}

/**
 * Model Passenger
 * 
 */
export type Passenger = runtime.Types.DefaultSelection<PassengerPayload>
export type ItineraryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Itinerary"
  objects: {
    Booking: BookingPayload<ExtArgs> | null
    Route: RoutePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    duration: string | null
    bookingId: string | null
  }, ExtArgs["result"]["itinerary"]>
  composites: {}
}

/**
 * Model Itinerary
 * 
 */
export type Itinerary = runtime.Types.DefaultSelection<ItineraryPayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Document"
  objects: {
    Passenger: PassengerPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    number: string | null
    issuanceDate: string | null
    expiryDate: string | null
    issuanceCountryCode: string | null
    issuanceLocation: string | null
    nationality: string | null
    documentType: string | null
    passengerId: string | null
    holder: boolean | null
    birthPlace: string | null
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>
export type PricePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Price"
  objects: {
    Booking: BookingPayload<ExtArgs> | null
    Fee: FeePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    basePrice: string | null
    grandTotal: string | null
    discountAmt: string | null
    commissionAmt: string | null
    currency: string | null
    bookingId: string | null
  }, ExtArgs["result"]["price"]>
  composites: {}
}

/**
 * Model Price
 * 
 */
export type Price = runtime.Types.DefaultSelection<PricePayload>
export type FeePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Fee"
  objects: {
    Price: PricePayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    type: string | null
    amount: string | null
    refundable: string | null
    currency: string | null
    priceId: string | null
  }, ExtArgs["result"]["fee"]>
  composites: {}
}

/**
 * Model Fee
 * 
 */
export type Fee = runtime.Types.DefaultSelection<FeePayload>
export type BaggagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Baggage"
  objects: {
    Passenger: PassengerPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    quantity: number | null
    weight: string | null
    type: string | null
    passengerId: string | null
  }, ExtArgs["result"]["baggage"]>
  composites: {}
}

/**
 * Model Baggage
 * 
 */
export type Baggage = runtime.Types.DefaultSelection<BaggagePayload>
export type RoutePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Route"
  objects: {
    Itinerary: ItineraryPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    departIataCode: string | null
    departTerminal: string | null
    departAt: string | null
    arrivalIataCode: string | null
    arrivalTerminal: string | null
    arrivalAt: string | null
    flightNumber: string | null
    aircraftCode: string | null
    duration: string | null
    numberOfStops: number | null
    carrierCode: string | null
    routeId: string | null
    itineraryId: string | null
  }, ExtArgs["result"]["route"]>
  composites: {}
}

/**
 * Model Route
 * 
 */
export type Route = runtime.Types.DefaultSelection<RoutePayload>
export type fareDetailsByRoutePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "fareDetailsByRoute"
  objects: {
    Passenger: PassengerPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    routeId: string | null
    fareBasis: string | null
    class: string | null
    brandedFare: string | null
    includedCheckedBagsUnit: number | null
    includedCheckedBagsWeight: number | null
    includedCheckedBagsWeightUnit: string | null
    cabin: string | null
    passengerId: string | null
  }, ExtArgs["result"]["fareDetailsByRoute"]>
  composites: {}
}

/**
 * Model fareDetailsByRoute
 * 
 */
export type fareDetailsByRoute = runtime.Types.DefaultSelection<fareDetailsByRoutePayload>
export type UsersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Users"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string | null
    email: string | null
    password: string | null
    accesstoken: string | null
    refreshtoken: string | null
  }, ExtArgs["result"]["users"]>
  composites: {}
}

/**
 * Model Users
 * 
 */
export type Users = runtime.Types.DefaultSelection<UsersPayload>
export type paymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "payment"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    enable: boolean | null
    regionality: string | null
    provider: string | null
    validTill: Date | null
  }, ExtArgs["result"]["payment"]>
  composites: {}
}

/**
 * Model payment
 * 
 */
export type payment = runtime.Types.DefaultSelection<paymentPayload>
export type loggingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "logging"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    corelationId: string | null
    date: string | null
    serviceType: string | null
    logType: string | null
    log: Prisma.JsonValue | null
    bookingId: string | null
  }, ExtArgs["result"]["logging"]>
  composites: {}
}

/**
 * Model logging
 * 
 */
export type logging = runtime.Types.DefaultSelection<loggingPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SpecialServiceRuleTables
 * const specialServiceRuleTables = await prisma.specialServiceRuleTable.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SpecialServiceRuleTables
   * const specialServiceRuleTables = await prisma.specialServiceRuleTable.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.specialServiceRuleTable`: Exposes CRUD operations for the **specialServiceRuleTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecialServiceRuleTables
    * const specialServiceRuleTables = await prisma.specialServiceRuleTable.findMany()
    * ```
    */
  get specialServiceRuleTable(): Prisma.specialServiceRuleTableDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.locationsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.passenger`: Exposes CRUD operations for the **Passenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passengers
    * const passengers = await prisma.passenger.findMany()
    * ```
    */
  get passenger(): Prisma.PassengerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.itinerary`: Exposes CRUD operations for the **Itinerary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itineraries
    * const itineraries = await prisma.itinerary.findMany()
    * ```
    */
  get itinerary(): Prisma.ItineraryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.price`: Exposes CRUD operations for the **Price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.price.findMany()
    * ```
    */
  get price(): Prisma.PriceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.fee`: Exposes CRUD operations for the **Fee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fees
    * const fees = await prisma.fee.findMany()
    * ```
    */
  get fee(): Prisma.FeeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.baggage`: Exposes CRUD operations for the **Baggage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Baggages
    * const baggages = await prisma.baggage.findMany()
    * ```
    */
  get baggage(): Prisma.BaggageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.route`: Exposes CRUD operations for the **Route** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routes
    * const routes = await prisma.route.findMany()
    * ```
    */
  get route(): Prisma.RouteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.fareDetailsByRoute`: Exposes CRUD operations for the **fareDetailsByRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FareDetailsByRoutes
    * const fareDetailsByRoutes = await prisma.fareDetailsByRoute.findMany()
    * ```
    */
  get fareDetailsByRoute(): Prisma.fareDetailsByRouteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.logging`: Exposes CRUD operations for the **logging** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loggings
    * const loggings = await prisma.logging.findMany()
    * ```
    */
  get logging(): Prisma.loggingDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    specialServiceRuleTable: 'specialServiceRuleTable',
    locations: 'locations',
    Booking: 'Booking',
    Passenger: 'Passenger',
    Itinerary: 'Itinerary',
    Document: 'Document',
    Price: 'Price',
    Fee: 'Fee',
    Baggage: 'Baggage',
    Route: 'Route',
    fareDetailsByRoute: 'fareDetailsByRoute',
    Users: 'Users',
    payment: 'payment',
    logging: 'logging'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'specialServiceRuleTable' | 'locations' | 'booking' | 'passenger' | 'itinerary' | 'document' | 'price' | 'fee' | 'baggage' | 'route' | 'fareDetailsByRoute' | 'users' | 'payment' | 'logging'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      specialServiceRuleTable: {
        payload: specialServiceRuleTablePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.specialServiceRuleTableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.specialServiceRuleTableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload>
          }
          findFirst: {
            args: Prisma.specialServiceRuleTableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.specialServiceRuleTableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload>
          }
          findMany: {
            args: Prisma.specialServiceRuleTableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload>[]
          }
          create: {
            args: Prisma.specialServiceRuleTableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload>
          }
          createMany: {
            args: Prisma.specialServiceRuleTableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.specialServiceRuleTableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload>
          }
          update: {
            args: Prisma.specialServiceRuleTableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload>
          }
          deleteMany: {
            args: Prisma.specialServiceRuleTableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.specialServiceRuleTableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.specialServiceRuleTableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<specialServiceRuleTablePayload>
          }
          aggregate: {
            args: Prisma.SpecialServiceRuleTableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpecialServiceRuleTable>
          }
          groupBy: {
            args: Prisma.SpecialServiceRuleTableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpecialServiceRuleTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.specialServiceRuleTableCountArgs<ExtArgs>,
            result: $Utils.Optional<SpecialServiceRuleTableCountAggregateOutputType> | number
          }
        }
      }
      locations: {
        payload: locationsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.locationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload>
          }
          findFirst: {
            args: Prisma.locationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload>
          }
          findMany: {
            args: Prisma.locationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload>[]
          }
          create: {
            args: Prisma.locationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload>
          }
          createMany: {
            args: Prisma.locationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.locationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload>
          }
          update: {
            args: Prisma.locationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload>
          }
          deleteMany: {
            args: Prisma.locationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.locationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.locationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.LocationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationsCountArgs<ExtArgs>,
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: BookingPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>,
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Passenger: {
        payload: PassengerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PassengerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload>
          }
          findFirst: {
            args: Prisma.PassengerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload>
          }
          findMany: {
            args: Prisma.PassengerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload>[]
          }
          create: {
            args: Prisma.PassengerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload>
          }
          createMany: {
            args: Prisma.PassengerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PassengerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload>
          }
          update: {
            args: Prisma.PassengerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload>
          }
          deleteMany: {
            args: Prisma.PassengerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PassengerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PassengerPayload>
          }
          aggregate: {
            args: Prisma.PassengerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePassenger>
          }
          groupBy: {
            args: Prisma.PassengerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerCountArgs<ExtArgs>,
            result: $Utils.Optional<PassengerCountAggregateOutputType> | number
          }
        }
      }
      Itinerary: {
        payload: ItineraryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ItineraryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload>
          }
          findFirst: {
            args: Prisma.ItineraryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload>
          }
          findMany: {
            args: Prisma.ItineraryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload>[]
          }
          create: {
            args: Prisma.ItineraryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload>
          }
          createMany: {
            args: Prisma.ItineraryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItineraryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload>
          }
          update: {
            args: Prisma.ItineraryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItineraryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ItineraryPayload>
          }
          aggregate: {
            args: Prisma.ItineraryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItinerary>
          }
          groupBy: {
            args: Prisma.ItineraryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItineraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryCountArgs<ExtArgs>,
            result: $Utils.Optional<ItineraryCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: DocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Price: {
        payload: PricePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PriceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload>
          }
          findFirst: {
            args: Prisma.PriceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload>
          }
          findMany: {
            args: Prisma.PriceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload>[]
          }
          create: {
            args: Prisma.PriceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload>
          }
          createMany: {
            args: Prisma.PriceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PriceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload>
          }
          update: {
            args: Prisma.PriceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload>
          }
          deleteMany: {
            args: Prisma.PriceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PriceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PriceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PricePayload>
          }
          aggregate: {
            args: Prisma.PriceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrice>
          }
          groupBy: {
            args: Prisma.PriceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceCountArgs<ExtArgs>,
            result: $Utils.Optional<PriceCountAggregateOutputType> | number
          }
        }
      }
      Fee: {
        payload: FeePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.FeeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload>
          }
          findFirst: {
            args: Prisma.FeeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload>
          }
          findMany: {
            args: Prisma.FeeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload>[]
          }
          create: {
            args: Prisma.FeeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload>
          }
          createMany: {
            args: Prisma.FeeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload>
          }
          update: {
            args: Prisma.FeeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload>
          }
          deleteMany: {
            args: Prisma.FeeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FeePayload>
          }
          aggregate: {
            args: Prisma.FeeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFee>
          }
          groupBy: {
            args: Prisma.FeeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeCountArgs<ExtArgs>,
            result: $Utils.Optional<FeeCountAggregateOutputType> | number
          }
        }
      }
      Baggage: {
        payload: BaggagePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BaggageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaggageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload>
          }
          findFirst: {
            args: Prisma.BaggageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaggageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload>
          }
          findMany: {
            args: Prisma.BaggageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload>[]
          }
          create: {
            args: Prisma.BaggageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload>
          }
          createMany: {
            args: Prisma.BaggageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BaggageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload>
          }
          update: {
            args: Prisma.BaggageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload>
          }
          deleteMany: {
            args: Prisma.BaggageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BaggageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BaggageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BaggagePayload>
          }
          aggregate: {
            args: Prisma.BaggageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBaggage>
          }
          groupBy: {
            args: Prisma.BaggageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BaggageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaggageCountArgs<ExtArgs>,
            result: $Utils.Optional<BaggageCountAggregateOutputType> | number
          }
        }
      }
      Route: {
        payload: RoutePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RouteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload>
          }
          findFirst: {
            args: Prisma.RouteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload>
          }
          findMany: {
            args: Prisma.RouteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload>[]
          }
          create: {
            args: Prisma.RouteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload>
          }
          createMany: {
            args: Prisma.RouteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RouteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload>
          }
          update: {
            args: Prisma.RouteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload>
          }
          deleteMany: {
            args: Prisma.RouteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RouteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RouteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RoutePayload>
          }
          aggregate: {
            args: Prisma.RouteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoute>
          }
          groupBy: {
            args: Prisma.RouteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCountArgs<ExtArgs>,
            result: $Utils.Optional<RouteCountAggregateOutputType> | number
          }
        }
      }
      fareDetailsByRoute: {
        payload: fareDetailsByRoutePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.fareDetailsByRouteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fareDetailsByRouteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload>
          }
          findFirst: {
            args: Prisma.fareDetailsByRouteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fareDetailsByRouteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload>
          }
          findMany: {
            args: Prisma.fareDetailsByRouteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload>[]
          }
          create: {
            args: Prisma.fareDetailsByRouteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload>
          }
          createMany: {
            args: Prisma.fareDetailsByRouteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fareDetailsByRouteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload>
          }
          update: {
            args: Prisma.fareDetailsByRouteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload>
          }
          deleteMany: {
            args: Prisma.fareDetailsByRouteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fareDetailsByRouteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fareDetailsByRouteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fareDetailsByRoutePayload>
          }
          aggregate: {
            args: Prisma.FareDetailsByRouteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFareDetailsByRoute>
          }
          groupBy: {
            args: Prisma.FareDetailsByRouteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FareDetailsByRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.fareDetailsByRouteCountArgs<ExtArgs>,
            result: $Utils.Optional<FareDetailsByRouteCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: UsersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: paymentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      logging: {
        payload: loggingPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.loggingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loggingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload>
          }
          findFirst: {
            args: Prisma.loggingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loggingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload>
          }
          findMany: {
            args: Prisma.loggingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload>[]
          }
          create: {
            args: Prisma.loggingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload>
          }
          createMany: {
            args: Prisma.loggingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.loggingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload>
          }
          update: {
            args: Prisma.loggingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload>
          }
          deleteMany: {
            args: Prisma.loggingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.loggingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.loggingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<loggingPayload>
          }
          aggregate: {
            args: Prisma.LoggingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogging>
          }
          groupBy: {
            args: Prisma.LoggingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LoggingGroupByOutputType>[]
          }
          count: {
            args: Prisma.loggingCountArgs<ExtArgs>,
            result: $Utils.Optional<LoggingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BookingCountOutputType
   */


  export type BookingCountOutputType = {
    Passenger: number
    Itinerary: number
    Price: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Passenger?: boolean | BookingCountOutputTypeCountPassengerArgs
    Itinerary?: boolean | BookingCountOutputTypeCountItineraryArgs
    Price?: boolean | BookingCountOutputTypeCountPriceArgs
  }

  // Custom InputTypes

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPassengerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
  }


  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountItineraryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }


  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPriceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
  }



  /**
   * Count Type PassengerCountOutputType
   */


  export type PassengerCountOutputType = {
    Document: number
    Baggage: number
    fareDetailsByRoute: number
  }

  export type PassengerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Document?: boolean | PassengerCountOutputTypeCountDocumentArgs
    Baggage?: boolean | PassengerCountOutputTypeCountBaggageArgs
    fareDetailsByRoute?: boolean | PassengerCountOutputTypeCountFareDetailsByRouteArgs
  }

  // Custom InputTypes

  /**
   * PassengerCountOutputType without action
   */
  export type PassengerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerCountOutputType
     */
    select?: PassengerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PassengerCountOutputType without action
   */
  export type PassengerCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * PassengerCountOutputType without action
   */
  export type PassengerCountOutputTypeCountBaggageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BaggageWhereInput
  }


  /**
   * PassengerCountOutputType without action
   */
  export type PassengerCountOutputTypeCountFareDetailsByRouteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fareDetailsByRouteWhereInput
  }



  /**
   * Count Type ItineraryCountOutputType
   */


  export type ItineraryCountOutputType = {
    Route: number
  }

  export type ItineraryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Route?: boolean | ItineraryCountOutputTypeCountRouteArgs
  }

  // Custom InputTypes

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryCountOutputType
     */
    select?: ItineraryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountRouteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
  }



  /**
   * Count Type PriceCountOutputType
   */


  export type PriceCountOutputType = {
    Fee: number
  }

  export type PriceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Fee?: boolean | PriceCountOutputTypeCountFeeArgs
  }

  // Custom InputTypes

  /**
   * PriceCountOutputType without action
   */
  export type PriceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceCountOutputType
     */
    select?: PriceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PriceCountOutputType without action
   */
  export type PriceCountOutputTypeCountFeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
  }



  /**
   * Models
   */

  /**
   * Model specialServiceRuleTable
   */


  export type AggregateSpecialServiceRuleTable = {
    _count: SpecialServiceRuleTableCountAggregateOutputType | null
    _min: SpecialServiceRuleTableMinAggregateOutputType | null
    _max: SpecialServiceRuleTableMaxAggregateOutputType | null
  }

  export type SpecialServiceRuleTableMinAggregateOutputType = {
    id: string | null
    enable: boolean | null
    currency: string | null
    origin: string | null
    destination: string | null
    carriercode: string | null
    offermeals: boolean | null
    offerseats: boolean | null
    Offerfrequentflyermiles: boolean | null
    offerpricewithincludedbaggage: boolean | null
  }

  export type SpecialServiceRuleTableMaxAggregateOutputType = {
    id: string | null
    enable: boolean | null
    currency: string | null
    origin: string | null
    destination: string | null
    carriercode: string | null
    offermeals: boolean | null
    offerseats: boolean | null
    Offerfrequentflyermiles: boolean | null
    offerpricewithincludedbaggage: boolean | null
  }

  export type SpecialServiceRuleTableCountAggregateOutputType = {
    id: number
    enable: number
    currency: number
    origin: number
    destination: number
    carriercode: number
    offermeals: number
    offerseats: number
    Offerfrequentflyermiles: number
    offerpricewithincludedbaggage: number
    _all: number
  }


  export type SpecialServiceRuleTableMinAggregateInputType = {
    id?: true
    enable?: true
    currency?: true
    origin?: true
    destination?: true
    carriercode?: true
    offermeals?: true
    offerseats?: true
    Offerfrequentflyermiles?: true
    offerpricewithincludedbaggage?: true
  }

  export type SpecialServiceRuleTableMaxAggregateInputType = {
    id?: true
    enable?: true
    currency?: true
    origin?: true
    destination?: true
    carriercode?: true
    offermeals?: true
    offerseats?: true
    Offerfrequentflyermiles?: true
    offerpricewithincludedbaggage?: true
  }

  export type SpecialServiceRuleTableCountAggregateInputType = {
    id?: true
    enable?: true
    currency?: true
    origin?: true
    destination?: true
    carriercode?: true
    offermeals?: true
    offerseats?: true
    Offerfrequentflyermiles?: true
    offerpricewithincludedbaggage?: true
    _all?: true
  }

  export type SpecialServiceRuleTableAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which specialServiceRuleTable to aggregate.
     */
    where?: specialServiceRuleTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialServiceRuleTables to fetch.
     */
    orderBy?: Enumerable<specialServiceRuleTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: specialServiceRuleTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialServiceRuleTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialServiceRuleTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned specialServiceRuleTables
    **/
    _count?: true | SpecialServiceRuleTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialServiceRuleTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialServiceRuleTableMaxAggregateInputType
  }

  export type GetSpecialServiceRuleTableAggregateType<T extends SpecialServiceRuleTableAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialServiceRuleTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialServiceRuleTable[P]>
      : GetScalarType<T[P], AggregateSpecialServiceRuleTable[P]>
  }




  export type SpecialServiceRuleTableGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: specialServiceRuleTableWhereInput
    orderBy?: Enumerable<specialServiceRuleTableOrderByWithAggregationInput>
    by: SpecialServiceRuleTableScalarFieldEnum[]
    having?: specialServiceRuleTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialServiceRuleTableCountAggregateInputType | true
    _min?: SpecialServiceRuleTableMinAggregateInputType
    _max?: SpecialServiceRuleTableMaxAggregateInputType
  }


  export type SpecialServiceRuleTableGroupByOutputType = {
    id: string
    enable: boolean | null
    currency: string | null
    origin: string | null
    destination: string | null
    carriercode: string | null
    offermeals: boolean | null
    offerseats: boolean | null
    Offerfrequentflyermiles: boolean | null
    offerpricewithincludedbaggage: boolean | null
    _count: SpecialServiceRuleTableCountAggregateOutputType | null
    _min: SpecialServiceRuleTableMinAggregateOutputType | null
    _max: SpecialServiceRuleTableMaxAggregateOutputType | null
  }

  type GetSpecialServiceRuleTableGroupByPayload<T extends SpecialServiceRuleTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SpecialServiceRuleTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialServiceRuleTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialServiceRuleTableGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialServiceRuleTableGroupByOutputType[P]>
        }
      >
    >


  export type specialServiceRuleTableSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enable?: boolean
    currency?: boolean
    origin?: boolean
    destination?: boolean
    carriercode?: boolean
    offermeals?: boolean
    offerseats?: boolean
    Offerfrequentflyermiles?: boolean
    offerpricewithincludedbaggage?: boolean
  }, ExtArgs["result"]["specialServiceRuleTable"]>

  export type specialServiceRuleTableSelectScalar = {
    id?: boolean
    enable?: boolean
    currency?: boolean
    origin?: boolean
    destination?: boolean
    carriercode?: boolean
    offermeals?: boolean
    offerseats?: boolean
    Offerfrequentflyermiles?: boolean
    offerpricewithincludedbaggage?: boolean
  }


  type specialServiceRuleTableGetPayload<S extends boolean | null | undefined | specialServiceRuleTableArgs> = $Types.GetResult<specialServiceRuleTablePayload, S>

  type specialServiceRuleTableCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<specialServiceRuleTableFindManyArgs, 'select' | 'include'> & {
      select?: SpecialServiceRuleTableCountAggregateInputType | true
    }

  export interface specialServiceRuleTableDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['specialServiceRuleTable'], meta: { name: 'specialServiceRuleTable' } }
    /**
     * Find zero or one SpecialServiceRuleTable that matches the filter.
     * @param {specialServiceRuleTableFindUniqueArgs} args - Arguments to find a SpecialServiceRuleTable
     * @example
     * // Get one SpecialServiceRuleTable
     * const specialServiceRuleTable = await prisma.specialServiceRuleTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends specialServiceRuleTableFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, specialServiceRuleTableFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'specialServiceRuleTable'> extends True ? Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SpecialServiceRuleTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {specialServiceRuleTableFindUniqueOrThrowArgs} args - Arguments to find a SpecialServiceRuleTable
     * @example
     * // Get one SpecialServiceRuleTable
     * const specialServiceRuleTable = await prisma.specialServiceRuleTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends specialServiceRuleTableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, specialServiceRuleTableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SpecialServiceRuleTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialServiceRuleTableFindFirstArgs} args - Arguments to find a SpecialServiceRuleTable
     * @example
     * // Get one SpecialServiceRuleTable
     * const specialServiceRuleTable = await prisma.specialServiceRuleTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends specialServiceRuleTableFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, specialServiceRuleTableFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'specialServiceRuleTable'> extends True ? Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SpecialServiceRuleTable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialServiceRuleTableFindFirstOrThrowArgs} args - Arguments to find a SpecialServiceRuleTable
     * @example
     * // Get one SpecialServiceRuleTable
     * const specialServiceRuleTable = await prisma.specialServiceRuleTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends specialServiceRuleTableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, specialServiceRuleTableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SpecialServiceRuleTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialServiceRuleTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecialServiceRuleTables
     * const specialServiceRuleTables = await prisma.specialServiceRuleTable.findMany()
     * 
     * // Get first 10 SpecialServiceRuleTables
     * const specialServiceRuleTables = await prisma.specialServiceRuleTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialServiceRuleTableWithIdOnly = await prisma.specialServiceRuleTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends specialServiceRuleTableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, specialServiceRuleTableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SpecialServiceRuleTable.
     * @param {specialServiceRuleTableCreateArgs} args - Arguments to create a SpecialServiceRuleTable.
     * @example
     * // Create one SpecialServiceRuleTable
     * const SpecialServiceRuleTable = await prisma.specialServiceRuleTable.create({
     *   data: {
     *     // ... data to create a SpecialServiceRuleTable
     *   }
     * })
     * 
    **/
    create<T extends specialServiceRuleTableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, specialServiceRuleTableCreateArgs<ExtArgs>>
    ): Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SpecialServiceRuleTables.
     *     @param {specialServiceRuleTableCreateManyArgs} args - Arguments to create many SpecialServiceRuleTables.
     *     @example
     *     // Create many SpecialServiceRuleTables
     *     const specialServiceRuleTable = await prisma.specialServiceRuleTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends specialServiceRuleTableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, specialServiceRuleTableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpecialServiceRuleTable.
     * @param {specialServiceRuleTableDeleteArgs} args - Arguments to delete one SpecialServiceRuleTable.
     * @example
     * // Delete one SpecialServiceRuleTable
     * const SpecialServiceRuleTable = await prisma.specialServiceRuleTable.delete({
     *   where: {
     *     // ... filter to delete one SpecialServiceRuleTable
     *   }
     * })
     * 
    **/
    delete<T extends specialServiceRuleTableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, specialServiceRuleTableDeleteArgs<ExtArgs>>
    ): Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SpecialServiceRuleTable.
     * @param {specialServiceRuleTableUpdateArgs} args - Arguments to update one SpecialServiceRuleTable.
     * @example
     * // Update one SpecialServiceRuleTable
     * const specialServiceRuleTable = await prisma.specialServiceRuleTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends specialServiceRuleTableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, specialServiceRuleTableUpdateArgs<ExtArgs>>
    ): Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SpecialServiceRuleTables.
     * @param {specialServiceRuleTableDeleteManyArgs} args - Arguments to filter SpecialServiceRuleTables to delete.
     * @example
     * // Delete a few SpecialServiceRuleTables
     * const { count } = await prisma.specialServiceRuleTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends specialServiceRuleTableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, specialServiceRuleTableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialServiceRuleTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialServiceRuleTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecialServiceRuleTables
     * const specialServiceRuleTable = await prisma.specialServiceRuleTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends specialServiceRuleTableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, specialServiceRuleTableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpecialServiceRuleTable.
     * @param {specialServiceRuleTableUpsertArgs} args - Arguments to update or create a SpecialServiceRuleTable.
     * @example
     * // Update or create a SpecialServiceRuleTable
     * const specialServiceRuleTable = await prisma.specialServiceRuleTable.upsert({
     *   create: {
     *     // ... data to create a SpecialServiceRuleTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecialServiceRuleTable we want to update
     *   }
     * })
    **/
    upsert<T extends specialServiceRuleTableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, specialServiceRuleTableUpsertArgs<ExtArgs>>
    ): Prisma__specialServiceRuleTableClient<$Types.GetResult<specialServiceRuleTablePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SpecialServiceRuleTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specialServiceRuleTableCountArgs} args - Arguments to filter SpecialServiceRuleTables to count.
     * @example
     * // Count the number of SpecialServiceRuleTables
     * const count = await prisma.specialServiceRuleTable.count({
     *   where: {
     *     // ... the filter for the SpecialServiceRuleTables we want to count
     *   }
     * })
    **/
    count<T extends specialServiceRuleTableCountArgs>(
      args?: Subset<T, specialServiceRuleTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialServiceRuleTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecialServiceRuleTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialServiceRuleTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialServiceRuleTableAggregateArgs>(args: Subset<T, SpecialServiceRuleTableAggregateArgs>): Prisma.PrismaPromise<GetSpecialServiceRuleTableAggregateType<T>>

    /**
     * Group by SpecialServiceRuleTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialServiceRuleTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialServiceRuleTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialServiceRuleTableGroupByArgs['orderBy'] }
        : { orderBy?: SpecialServiceRuleTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialServiceRuleTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialServiceRuleTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for specialServiceRuleTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__specialServiceRuleTableClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * specialServiceRuleTable base type for findUnique actions
   */
  export type specialServiceRuleTableFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * Filter, which specialServiceRuleTable to fetch.
     */
    where: specialServiceRuleTableWhereUniqueInput
  }

  /**
   * specialServiceRuleTable findUnique
   */
  export interface specialServiceRuleTableFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends specialServiceRuleTableFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * specialServiceRuleTable findUniqueOrThrow
   */
  export type specialServiceRuleTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * Filter, which specialServiceRuleTable to fetch.
     */
    where: specialServiceRuleTableWhereUniqueInput
  }


  /**
   * specialServiceRuleTable base type for findFirst actions
   */
  export type specialServiceRuleTableFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * Filter, which specialServiceRuleTable to fetch.
     */
    where?: specialServiceRuleTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialServiceRuleTables to fetch.
     */
    orderBy?: Enumerable<specialServiceRuleTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specialServiceRuleTables.
     */
    cursor?: specialServiceRuleTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialServiceRuleTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialServiceRuleTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specialServiceRuleTables.
     */
    distinct?: Enumerable<SpecialServiceRuleTableScalarFieldEnum>
  }

  /**
   * specialServiceRuleTable findFirst
   */
  export interface specialServiceRuleTableFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends specialServiceRuleTableFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * specialServiceRuleTable findFirstOrThrow
   */
  export type specialServiceRuleTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * Filter, which specialServiceRuleTable to fetch.
     */
    where?: specialServiceRuleTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialServiceRuleTables to fetch.
     */
    orderBy?: Enumerable<specialServiceRuleTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specialServiceRuleTables.
     */
    cursor?: specialServiceRuleTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialServiceRuleTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialServiceRuleTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specialServiceRuleTables.
     */
    distinct?: Enumerable<SpecialServiceRuleTableScalarFieldEnum>
  }


  /**
   * specialServiceRuleTable findMany
   */
  export type specialServiceRuleTableFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * Filter, which specialServiceRuleTables to fetch.
     */
    where?: specialServiceRuleTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specialServiceRuleTables to fetch.
     */
    orderBy?: Enumerable<specialServiceRuleTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing specialServiceRuleTables.
     */
    cursor?: specialServiceRuleTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specialServiceRuleTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specialServiceRuleTables.
     */
    skip?: number
    distinct?: Enumerable<SpecialServiceRuleTableScalarFieldEnum>
  }


  /**
   * specialServiceRuleTable create
   */
  export type specialServiceRuleTableCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * The data needed to create a specialServiceRuleTable.
     */
    data?: XOR<specialServiceRuleTableCreateInput, specialServiceRuleTableUncheckedCreateInput>
  }


  /**
   * specialServiceRuleTable createMany
   */
  export type specialServiceRuleTableCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many specialServiceRuleTables.
     */
    data: Enumerable<specialServiceRuleTableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * specialServiceRuleTable update
   */
  export type specialServiceRuleTableUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * The data needed to update a specialServiceRuleTable.
     */
    data: XOR<specialServiceRuleTableUpdateInput, specialServiceRuleTableUncheckedUpdateInput>
    /**
     * Choose, which specialServiceRuleTable to update.
     */
    where: specialServiceRuleTableWhereUniqueInput
  }


  /**
   * specialServiceRuleTable updateMany
   */
  export type specialServiceRuleTableUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update specialServiceRuleTables.
     */
    data: XOR<specialServiceRuleTableUpdateManyMutationInput, specialServiceRuleTableUncheckedUpdateManyInput>
    /**
     * Filter which specialServiceRuleTables to update
     */
    where?: specialServiceRuleTableWhereInput
  }


  /**
   * specialServiceRuleTable upsert
   */
  export type specialServiceRuleTableUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * The filter to search for the specialServiceRuleTable to update in case it exists.
     */
    where: specialServiceRuleTableWhereUniqueInput
    /**
     * In case the specialServiceRuleTable found by the `where` argument doesn't exist, create a new specialServiceRuleTable with this data.
     */
    create: XOR<specialServiceRuleTableCreateInput, specialServiceRuleTableUncheckedCreateInput>
    /**
     * In case the specialServiceRuleTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<specialServiceRuleTableUpdateInput, specialServiceRuleTableUncheckedUpdateInput>
  }


  /**
   * specialServiceRuleTable delete
   */
  export type specialServiceRuleTableDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
    /**
     * Filter which specialServiceRuleTable to delete.
     */
    where: specialServiceRuleTableWhereUniqueInput
  }


  /**
   * specialServiceRuleTable deleteMany
   */
  export type specialServiceRuleTableDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which specialServiceRuleTables to delete
     */
    where?: specialServiceRuleTableWhereInput
  }


  /**
   * specialServiceRuleTable without action
   */
  export type specialServiceRuleTableArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specialServiceRuleTable
     */
    select?: specialServiceRuleTableSelect<ExtArgs> | null
  }



  /**
   * Model locations
   */


  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsMinAggregateOutputType = {
    id: string | null
    iata: string | null
    cityName: string | null
    airportName: string | null
    country: string | null
    countryCode: string | null
    icon: string | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: string | null
    iata: string | null
    cityName: string | null
    airportName: string | null
    country: string | null
    countryCode: string | null
    icon: string | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    iata: number
    cityName: number
    airportName: number
    country: number
    countryCode: number
    icon: number
    _all: number
  }


  export type LocationsMinAggregateInputType = {
    id?: true
    iata?: true
    cityName?: true
    airportName?: true
    country?: true
    countryCode?: true
    icon?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    iata?: true
    cityName?: true
    airportName?: true
    country?: true
    countryCode?: true
    icon?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    iata?: true
    cityName?: true
    airportName?: true
    country?: true
    countryCode?: true
    icon?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to aggregate.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type LocationsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
    orderBy?: Enumerable<locationsOrderByWithAggregationInput>
    by: LocationsScalarFieldEnum[]
    having?: locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }


  export type LocationsGroupByOutputType = {
    id: string
    iata: string | null
    cityName: string | null
    airportName: string | null
    country: string | null
    countryCode: string | null
    icon: string | null
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends LocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type locationsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iata?: boolean
    cityName?: boolean
    airportName?: boolean
    country?: boolean
    countryCode?: boolean
    icon?: boolean
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectScalar = {
    id?: boolean
    iata?: boolean
    cityName?: boolean
    airportName?: boolean
    country?: boolean
    countryCode?: boolean
    icon?: boolean
  }


  type locationsGetPayload<S extends boolean | null | undefined | locationsArgs> = $Types.GetResult<locationsPayload, S>

  type locationsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<locationsFindManyArgs, 'select' | 'include'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface locationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locations'], meta: { name: 'locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {locationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'locations'> extends True ? Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Locations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {locationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends locationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, locationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'locations'> extends True ? Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Locations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends locationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, locationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends locationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, locationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<locationsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Locations.
     * @param {locationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
    **/
    create<T extends locationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, locationsCreateArgs<ExtArgs>>
    ): Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Locations.
     *     @param {locationsCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const locations = await prisma.locations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends locationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, locationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Locations.
     * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
    **/
    delete<T extends locationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, locationsDeleteArgs<ExtArgs>>
    ): Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Locations.
     * @param {locationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, locationsUpdateArgs<ExtArgs>>
    ): Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, locationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, locationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locations.
     * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
    **/
    upsert<T extends locationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, locationsUpsertArgs<ExtArgs>>
    ): Prisma__locationsClient<$Types.GetResult<locationsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationsCountArgs>(
      args?: Subset<T, locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationsGroupByArgs['orderBy'] }
        : { orderBy?: LocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * locations base type for findUnique actions
   */
  export type locationsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findUnique
   */
  export interface locationsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends locationsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locations findUniqueOrThrow
   */
  export type locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations base type for findFirst actions
   */
  export type locationsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }

  /**
   * locations findFirst
   */
  export interface locationsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends locationsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locations findFirstOrThrow
   */
  export type locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * locations findMany
   */
  export type locationsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * locations create
   */
  export type locationsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * The data needed to create a locations.
     */
    data?: XOR<locationsCreateInput, locationsUncheckedCreateInput>
  }


  /**
   * locations createMany
   */
  export type locationsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: Enumerable<locationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * locations update
   */
  export type locationsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * The data needed to update a locations.
     */
    data: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
    /**
     * Choose, which locations to update.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations updateMany
   */
  export type locationsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
  }


  /**
   * locations upsert
   */
  export type locationsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * The filter to search for the locations to update in case it exists.
     */
    where: locationsWhereUniqueInput
    /**
     * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
     */
    create: XOR<locationsCreateInput, locationsUncheckedCreateInput>
    /**
     * In case the locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
  }


  /**
   * locations delete
   */
  export type locationsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Filter which locations to delete.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations deleteMany
   */
  export type locationsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationsWhereInput
  }


  /**
   * locations without action
   */
  export type locationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
  }



  /**
   * Model Booking
   */


  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    orderRef: string | null
    orderType: string | null
    status: string | null
    reference: string | null
    paymentIntentId: string | null
    paymentStatus: string | null
    supplier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeSessionId: string | null
    razorpayOrderId: string | null
    flightOfferId: string | null
    flightInternalSource: string | null
    userEmail: string | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    orderRef: string | null
    orderType: string | null
    status: string | null
    reference: string | null
    paymentIntentId: string | null
    paymentStatus: string | null
    supplier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeSessionId: string | null
    razorpayOrderId: string | null
    flightOfferId: string | null
    flightInternalSource: string | null
    userEmail: string | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    orderId: number
    orderRef: number
    orderType: number
    status: number
    reference: number
    paymentIntentId: number
    paymentStatus: number
    supplier: number
    createdAt: number
    updatedAt: number
    stripeSessionId: number
    razorpayOrderId: number
    flightOfferId: number
    flightInternalSource: number
    userEmail: number
    _all: number
  }


  export type BookingMinAggregateInputType = {
    id?: true
    orderId?: true
    orderRef?: true
    orderType?: true
    status?: true
    reference?: true
    paymentIntentId?: true
    paymentStatus?: true
    supplier?: true
    createdAt?: true
    updatedAt?: true
    stripeSessionId?: true
    razorpayOrderId?: true
    flightOfferId?: true
    flightInternalSource?: true
    userEmail?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    orderId?: true
    orderRef?: true
    orderType?: true
    status?: true
    reference?: true
    paymentIntentId?: true
    paymentStatus?: true
    supplier?: true
    createdAt?: true
    updatedAt?: true
    stripeSessionId?: true
    razorpayOrderId?: true
    flightOfferId?: true
    flightInternalSource?: true
    userEmail?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    orderId?: true
    orderRef?: true
    orderType?: true
    status?: true
    reference?: true
    paymentIntentId?: true
    paymentStatus?: true
    supplier?: true
    createdAt?: true
    updatedAt?: true
    stripeSessionId?: true
    razorpayOrderId?: true
    flightOfferId?: true
    flightInternalSource?: true
    userEmail?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: Enumerable<BookingOrderByWithAggregationInput>
    by: BookingScalarFieldEnum[]
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }


  export type BookingGroupByOutputType = {
    id: string
    orderId: string | null
    orderRef: string | null
    orderType: string | null
    status: string | null
    reference: string | null
    paymentIntentId: string | null
    paymentStatus: string | null
    supplier: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeSessionId: string | null
    razorpayOrderId: string | null
    flightOfferId: string | null
    flightInternalSource: string | null
    userEmail: string | null
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    orderRef?: boolean
    orderType?: boolean
    status?: boolean
    reference?: boolean
    paymentIntentId?: boolean
    paymentStatus?: boolean
    supplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeSessionId?: boolean
    razorpayOrderId?: boolean
    flightOfferId?: boolean
    flightInternalSource?: boolean
    userEmail?: boolean
    Passenger?: boolean | Booking$PassengerArgs<ExtArgs>
    Itinerary?: boolean | Booking$ItineraryArgs<ExtArgs>
    Price?: boolean | Booking$PriceArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    orderId?: boolean
    orderRef?: boolean
    orderType?: boolean
    status?: boolean
    reference?: boolean
    paymentIntentId?: boolean
    paymentStatus?: boolean
    supplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeSessionId?: boolean
    razorpayOrderId?: boolean
    flightOfferId?: boolean
    flightInternalSource?: boolean
    userEmail?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Passenger?: boolean | Booking$PassengerArgs<ExtArgs>
    Itinerary?: boolean | Booking$ItineraryArgs<ExtArgs>
    Price?: boolean | Booking$PriceArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeArgs<ExtArgs>
  }


  type BookingGetPayload<S extends boolean | null | undefined | BookingArgs> = $Types.GetResult<BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookingFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Booking'> extends True ? Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookingFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Booking'> extends True ? Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
    **/
    create<T extends BookingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BookingCreateArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Bookings.
     *     @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     *     @example
     *     // Create many Bookings
     *     const booking = await prisma.booking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
    **/
    delete<T extends BookingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
    **/
    upsert<T extends BookingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Passenger<T extends Booking$PassengerArgs<ExtArgs> = {}>(args?: Subset<T, Booking$PassengerArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    Itinerary<T extends Booking$ItineraryArgs<ExtArgs> = {}>(args?: Subset<T, Booking$ItineraryArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    Price<T extends Booking$PriceArgs<ExtArgs> = {}>(args?: Subset<T, Booking$PriceArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PricePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Booking base type for findUnique actions
   */
  export type BookingFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUnique
   */
  export interface BookingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BookingFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking base type for findFirst actions
   */
  export type BookingFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: Enumerable<BookingScalarFieldEnum>
  }

  /**
   * Booking findFirst
   */
  export interface BookingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BookingFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: Enumerable<BookingScalarFieldEnum>
  }


  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: Enumerable<BookingScalarFieldEnum>
  }


  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data?: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }


  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: Enumerable<BookingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }


  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }


  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }


  /**
   * Booking.Passenger
   */
  export type Booking$PassengerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    where?: PassengerWhereInput
    orderBy?: Enumerable<PassengerOrderByWithRelationInput>
    cursor?: PassengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PassengerScalarFieldEnum>
  }


  /**
   * Booking.Itinerary
   */
  export type Booking$ItineraryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: Enumerable<ItineraryOrderByWithRelationInput>
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItineraryScalarFieldEnum>
  }


  /**
   * Booking.Price
   */
  export type Booking$PriceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    where?: PriceWhereInput
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    cursor?: PriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Booking without action
   */
  export type BookingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
  }



  /**
   * Model Passenger
   */


  export type AggregatePassenger = {
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  export type PassengerMinAggregateOutputType = {
    id: string | null
    passengerId: string | null
    countryCode: string | null
    email: string | null
    dateOfBirth: string | null
    passengerType: string | null
    title: string | null
    gender: string | null
    firstName: string | null
    lastName: string | null
    seatNumber: string | null
    fareOption: string | null
    bookingId: string | null
    phone: string | null
  }

  export type PassengerMaxAggregateOutputType = {
    id: string | null
    passengerId: string | null
    countryCode: string | null
    email: string | null
    dateOfBirth: string | null
    passengerType: string | null
    title: string | null
    gender: string | null
    firstName: string | null
    lastName: string | null
    seatNumber: string | null
    fareOption: string | null
    bookingId: string | null
    phone: string | null
  }

  export type PassengerCountAggregateOutputType = {
    id: number
    passengerId: number
    countryCode: number
    email: number
    dateOfBirth: number
    passengerType: number
    title: number
    gender: number
    firstName: number
    lastName: number
    seatNumber: number
    fareOption: number
    bookingId: number
    phone: number
    _all: number
  }


  export type PassengerMinAggregateInputType = {
    id?: true
    passengerId?: true
    countryCode?: true
    email?: true
    dateOfBirth?: true
    passengerType?: true
    title?: true
    gender?: true
    firstName?: true
    lastName?: true
    seatNumber?: true
    fareOption?: true
    bookingId?: true
    phone?: true
  }

  export type PassengerMaxAggregateInputType = {
    id?: true
    passengerId?: true
    countryCode?: true
    email?: true
    dateOfBirth?: true
    passengerType?: true
    title?: true
    gender?: true
    firstName?: true
    lastName?: true
    seatNumber?: true
    fareOption?: true
    bookingId?: true
    phone?: true
  }

  export type PassengerCountAggregateInputType = {
    id?: true
    passengerId?: true
    countryCode?: true
    email?: true
    dateOfBirth?: true
    passengerType?: true
    title?: true
    gender?: true
    firstName?: true
    lastName?: true
    seatNumber?: true
    fareOption?: true
    bookingId?: true
    phone?: true
    _all?: true
  }

  export type PassengerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passenger to aggregate.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: Enumerable<PassengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passengers
    **/
    _count?: true | PassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerMaxAggregateInputType
  }

  export type GetPassengerAggregateType<T extends PassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger[P]>
      : GetScalarType<T[P], AggregatePassenger[P]>
  }




  export type PassengerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
    orderBy?: Enumerable<PassengerOrderByWithAggregationInput>
    by: PassengerScalarFieldEnum[]
    having?: PassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerCountAggregateInputType | true
    _min?: PassengerMinAggregateInputType
    _max?: PassengerMaxAggregateInputType
  }


  export type PassengerGroupByOutputType = {
    id: string
    passengerId: string | null
    countryCode: string | null
    email: string | null
    dateOfBirth: string | null
    passengerType: string | null
    title: string | null
    gender: string | null
    firstName: string | null
    lastName: string | null
    seatNumber: string | null
    fareOption: string | null
    bookingId: string | null
    phone: string | null
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  type GetPassengerGroupByPayload<T extends PassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerGroupByOutputType[P]>
        }
      >
    >


  export type PassengerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passengerId?: boolean
    countryCode?: boolean
    email?: boolean
    dateOfBirth?: boolean
    passengerType?: boolean
    title?: boolean
    gender?: boolean
    firstName?: boolean
    lastName?: boolean
    seatNumber?: boolean
    fareOption?: boolean
    bookingId?: boolean
    phone?: boolean
    Booking?: boolean | BookingArgs<ExtArgs>
    Document?: boolean | Passenger$DocumentArgs<ExtArgs>
    Baggage?: boolean | Passenger$BaggageArgs<ExtArgs>
    fareDetailsByRoute?: boolean | Passenger$fareDetailsByRouteArgs<ExtArgs>
    _count?: boolean | PassengerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectScalar = {
    id?: boolean
    passengerId?: boolean
    countryCode?: boolean
    email?: boolean
    dateOfBirth?: boolean
    passengerType?: boolean
    title?: boolean
    gender?: boolean
    firstName?: boolean
    lastName?: boolean
    seatNumber?: boolean
    fareOption?: boolean
    bookingId?: boolean
    phone?: boolean
  }

  export type PassengerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingArgs<ExtArgs>
    Document?: boolean | Passenger$DocumentArgs<ExtArgs>
    Baggage?: boolean | Passenger$BaggageArgs<ExtArgs>
    fareDetailsByRoute?: boolean | Passenger$fareDetailsByRouteArgs<ExtArgs>
    _count?: boolean | PassengerCountOutputTypeArgs<ExtArgs>
  }


  type PassengerGetPayload<S extends boolean | null | undefined | PassengerArgs> = $Types.GetResult<PassengerPayload, S>

  type PassengerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PassengerFindManyArgs, 'select' | 'include'> & {
      select?: PassengerCountAggregateInputType | true
    }

  export interface PassengerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passenger'], meta: { name: 'Passenger' } }
    /**
     * Find zero or one Passenger that matches the filter.
     * @param {PassengerFindUniqueArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PassengerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PassengerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Passenger'> extends True ? Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Passenger that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PassengerFindUniqueOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PassengerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PassengerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Passenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PassengerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PassengerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Passenger'> extends True ? Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Passenger that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PassengerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PassengerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Passengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passengers
     * const passengers = await prisma.passenger.findMany()
     * 
     * // Get first 10 Passengers
     * const passengers = await prisma.passenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerWithIdOnly = await prisma.passenger.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PassengerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PassengerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Passenger.
     * @param {PassengerCreateArgs} args - Arguments to create a Passenger.
     * @example
     * // Create one Passenger
     * const Passenger = await prisma.passenger.create({
     *   data: {
     *     // ... data to create a Passenger
     *   }
     * })
     * 
    **/
    create<T extends PassengerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PassengerCreateArgs<ExtArgs>>
    ): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Passengers.
     *     @param {PassengerCreateManyArgs} args - Arguments to create many Passengers.
     *     @example
     *     // Create many Passengers
     *     const passenger = await prisma.passenger.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PassengerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PassengerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Passenger.
     * @param {PassengerDeleteArgs} args - Arguments to delete one Passenger.
     * @example
     * // Delete one Passenger
     * const Passenger = await prisma.passenger.delete({
     *   where: {
     *     // ... filter to delete one Passenger
     *   }
     * })
     * 
    **/
    delete<T extends PassengerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PassengerDeleteArgs<ExtArgs>>
    ): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Passenger.
     * @param {PassengerUpdateArgs} args - Arguments to update one Passenger.
     * @example
     * // Update one Passenger
     * const passenger = await prisma.passenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PassengerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PassengerUpdateArgs<ExtArgs>>
    ): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Passengers.
     * @param {PassengerDeleteManyArgs} args - Arguments to filter Passengers to delete.
     * @example
     * // Delete a few Passengers
     * const { count } = await prisma.passenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PassengerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PassengerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PassengerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PassengerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Passenger.
     * @param {PassengerUpsertArgs} args - Arguments to update or create a Passenger.
     * @example
     * // Update or create a Passenger
     * const passenger = await prisma.passenger.upsert({
     *   create: {
     *     // ... data to create a Passenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger we want to update
     *   }
     * })
    **/
    upsert<T extends PassengerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PassengerUpsertArgs<ExtArgs>>
    ): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerCountArgs} args - Arguments to filter Passengers to count.
     * @example
     * // Count the number of Passengers
     * const count = await prisma.passenger.count({
     *   where: {
     *     // ... the filter for the Passengers we want to count
     *   }
     * })
    **/
    count<T extends PassengerCountArgs>(
      args?: Subset<T, PassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerAggregateArgs>(args: Subset<T, PassengerAggregateArgs>): Prisma.PrismaPromise<GetPassengerAggregateType<T>>

    /**
     * Group by Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerGroupByArgs['orderBy'] }
        : { orderBy?: PassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Passenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PassengerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Booking<T extends BookingArgs<ExtArgs> = {}>(args?: Subset<T, BookingArgs<ExtArgs>>): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Document<T extends Passenger$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, Passenger$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    Baggage<T extends Passenger$BaggageArgs<ExtArgs> = {}>(args?: Subset<T, Passenger$BaggageArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    fareDetailsByRoute<T extends Passenger$fareDetailsByRouteArgs<ExtArgs> = {}>(args?: Subset<T, Passenger$fareDetailsByRouteArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Passenger base type for findUnique actions
   */
  export type PassengerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findUnique
   */
  export interface PassengerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PassengerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Passenger findUniqueOrThrow
   */
  export type PassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }


  /**
   * Passenger base type for findFirst actions
   */
  export type PassengerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: Enumerable<PassengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: Enumerable<PassengerScalarFieldEnum>
  }

  /**
   * Passenger findFirst
   */
  export interface PassengerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PassengerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Passenger findFirstOrThrow
   */
  export type PassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: Enumerable<PassengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: Enumerable<PassengerScalarFieldEnum>
  }


  /**
   * Passenger findMany
   */
  export type PassengerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passengers to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: Enumerable<PassengerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    distinct?: Enumerable<PassengerScalarFieldEnum>
  }


  /**
   * Passenger create
   */
  export type PassengerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to create a Passenger.
     */
    data?: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
  }


  /**
   * Passenger createMany
   */
  export type PassengerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passengers.
     */
    data: Enumerable<PassengerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Passenger update
   */
  export type PassengerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to update a Passenger.
     */
    data: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
    /**
     * Choose, which Passenger to update.
     */
    where: PassengerWhereUniqueInput
  }


  /**
   * Passenger updateMany
   */
  export type PassengerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
  }


  /**
   * Passenger upsert
   */
  export type PassengerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The filter to search for the Passenger to update in case it exists.
     */
    where: PassengerWhereUniqueInput
    /**
     * In case the Passenger found by the `where` argument doesn't exist, create a new Passenger with this data.
     */
    create: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
    /**
     * In case the Passenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
  }


  /**
   * Passenger delete
   */
  export type PassengerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter which Passenger to delete.
     */
    where: PassengerWhereUniqueInput
  }


  /**
   * Passenger deleteMany
   */
  export type PassengerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passengers to delete
     */
    where?: PassengerWhereInput
  }


  /**
   * Passenger.Document
   */
  export type Passenger$DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Passenger.Baggage
   */
  export type Passenger$BaggageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    where?: BaggageWhereInput
    orderBy?: Enumerable<BaggageOrderByWithRelationInput>
    cursor?: BaggageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BaggageScalarFieldEnum>
  }


  /**
   * Passenger.fareDetailsByRoute
   */
  export type Passenger$fareDetailsByRouteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    where?: fareDetailsByRouteWhereInput
    orderBy?: Enumerable<fareDetailsByRouteOrderByWithRelationInput>
    cursor?: fareDetailsByRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FareDetailsByRouteScalarFieldEnum>
  }


  /**
   * Passenger without action
   */
  export type PassengerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PassengerInclude<ExtArgs> | null
  }



  /**
   * Model Itinerary
   */


  export type AggregateItinerary = {
    _count: ItineraryCountAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  export type ItineraryMinAggregateOutputType = {
    id: string | null
    duration: string | null
    bookingId: string | null
  }

  export type ItineraryMaxAggregateOutputType = {
    id: string | null
    duration: string | null
    bookingId: string | null
  }

  export type ItineraryCountAggregateOutputType = {
    id: number
    duration: number
    bookingId: number
    _all: number
  }


  export type ItineraryMinAggregateInputType = {
    id?: true
    duration?: true
    bookingId?: true
  }

  export type ItineraryMaxAggregateInputType = {
    id?: true
    duration?: true
    bookingId?: true
  }

  export type ItineraryCountAggregateInputType = {
    id?: true
    duration?: true
    bookingId?: true
    _all?: true
  }

  export type ItineraryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itinerary to aggregate.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: Enumerable<ItineraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Itineraries
    **/
    _count?: true | ItineraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryMaxAggregateInputType
  }

  export type GetItineraryAggregateType<T extends ItineraryAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerary[P]>
      : GetScalarType<T[P], AggregateItinerary[P]>
  }




  export type ItineraryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
    orderBy?: Enumerable<ItineraryOrderByWithAggregationInput>
    by: ItineraryScalarFieldEnum[]
    having?: ItineraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryCountAggregateInputType | true
    _min?: ItineraryMinAggregateInputType
    _max?: ItineraryMaxAggregateInputType
  }


  export type ItineraryGroupByOutputType = {
    id: string
    duration: string | null
    bookingId: string | null
    _count: ItineraryCountAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  type GetItineraryGroupByPayload<T extends ItineraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ItineraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    duration?: boolean
    bookingId?: boolean
    Booking?: boolean | BookingArgs<ExtArgs>
    Route?: boolean | Itinerary$RouteArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectScalar = {
    id?: boolean
    duration?: boolean
    bookingId?: boolean
  }

  export type ItineraryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingArgs<ExtArgs>
    Route?: boolean | Itinerary$RouteArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeArgs<ExtArgs>
  }


  type ItineraryGetPayload<S extends boolean | null | undefined | ItineraryArgs> = $Types.GetResult<ItineraryPayload, S>

  type ItineraryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ItineraryFindManyArgs, 'select' | 'include'> & {
      select?: ItineraryCountAggregateInputType | true
    }

  export interface ItineraryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Itinerary'], meta: { name: 'Itinerary' } }
    /**
     * Find zero or one Itinerary that matches the filter.
     * @param {ItineraryFindUniqueArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItineraryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItineraryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Itinerary'> extends True ? Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Itinerary that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItineraryFindUniqueOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItineraryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItineraryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItineraryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Itinerary'> extends True ? Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItineraryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Itineraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itineraries
     * const itineraries = await prisma.itinerary.findMany()
     * 
     * // Get first 10 Itineraries
     * const itineraries = await prisma.itinerary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItineraryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Itinerary.
     * @param {ItineraryCreateArgs} args - Arguments to create a Itinerary.
     * @example
     * // Create one Itinerary
     * const Itinerary = await prisma.itinerary.create({
     *   data: {
     *     // ... data to create a Itinerary
     *   }
     * })
     * 
    **/
    create<T extends ItineraryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryCreateArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Itineraries.
     *     @param {ItineraryCreateManyArgs} args - Arguments to create many Itineraries.
     *     @example
     *     // Create many Itineraries
     *     const itinerary = await prisma.itinerary.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItineraryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Itinerary.
     * @param {ItineraryDeleteArgs} args - Arguments to delete one Itinerary.
     * @example
     * // Delete one Itinerary
     * const Itinerary = await prisma.itinerary.delete({
     *   where: {
     *     // ... filter to delete one Itinerary
     *   }
     * })
     * 
    **/
    delete<T extends ItineraryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryDeleteArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Itinerary.
     * @param {ItineraryUpdateArgs} args - Arguments to update one Itinerary.
     * @example
     * // Update one Itinerary
     * const itinerary = await prisma.itinerary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItineraryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryUpdateArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Itineraries.
     * @param {ItineraryDeleteManyArgs} args - Arguments to filter Itineraries to delete.
     * @example
     * // Delete a few Itineraries
     * const { count } = await prisma.itinerary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItineraryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itineraries
     * const itinerary = await prisma.itinerary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItineraryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Itinerary.
     * @param {ItineraryUpsertArgs} args - Arguments to update or create a Itinerary.
     * @example
     * // Update or create a Itinerary
     * const itinerary = await prisma.itinerary.upsert({
     *   create: {
     *     // ... data to create a Itinerary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itinerary we want to update
     *   }
     * })
    **/
    upsert<T extends ItineraryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryUpsertArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryCountArgs} args - Arguments to filter Itineraries to count.
     * @example
     * // Count the number of Itineraries
     * const count = await prisma.itinerary.count({
     *   where: {
     *     // ... the filter for the Itineraries we want to count
     *   }
     * })
    **/
    count<T extends ItineraryCountArgs>(
      args?: Subset<T, ItineraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryAggregateArgs>(args: Subset<T, ItineraryAggregateArgs>): Prisma.PrismaPromise<GetItineraryAggregateType<T>>

    /**
     * Group by Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Itinerary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItineraryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Booking<T extends BookingArgs<ExtArgs> = {}>(args?: Subset<T, BookingArgs<ExtArgs>>): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Route<T extends Itinerary$RouteArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$RouteArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Itinerary base type for findUnique actions
   */
  export type ItineraryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findUnique
   */
  export interface ItineraryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ItineraryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Itinerary findUniqueOrThrow
   */
  export type ItineraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }


  /**
   * Itinerary base type for findFirst actions
   */
  export type ItineraryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: Enumerable<ItineraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: Enumerable<ItineraryScalarFieldEnum>
  }

  /**
   * Itinerary findFirst
   */
  export interface ItineraryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ItineraryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Itinerary findFirstOrThrow
   */
  export type ItineraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: Enumerable<ItineraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: Enumerable<ItineraryScalarFieldEnum>
  }


  /**
   * Itinerary findMany
   */
  export type ItineraryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itineraries to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: Enumerable<ItineraryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    distinct?: Enumerable<ItineraryScalarFieldEnum>
  }


  /**
   * Itinerary create
   */
  export type ItineraryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Itinerary.
     */
    data?: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
  }


  /**
   * Itinerary createMany
   */
  export type ItineraryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Itineraries.
     */
    data: Enumerable<ItineraryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Itinerary update
   */
  export type ItineraryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Itinerary.
     */
    data: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
    /**
     * Choose, which Itinerary to update.
     */
    where: ItineraryWhereUniqueInput
  }


  /**
   * Itinerary updateMany
   */
  export type ItineraryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Itineraries.
     */
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyInput>
    /**
     * Filter which Itineraries to update
     */
    where?: ItineraryWhereInput
  }


  /**
   * Itinerary upsert
   */
  export type ItineraryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Itinerary to update in case it exists.
     */
    where: ItineraryWhereUniqueInput
    /**
     * In case the Itinerary found by the `where` argument doesn't exist, create a new Itinerary with this data.
     */
    create: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
    /**
     * In case the Itinerary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
  }


  /**
   * Itinerary delete
   */
  export type ItineraryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter which Itinerary to delete.
     */
    where: ItineraryWhereUniqueInput
  }


  /**
   * Itinerary deleteMany
   */
  export type ItineraryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itineraries to delete
     */
    where?: ItineraryWhereInput
  }


  /**
   * Itinerary.Route
   */
  export type Itinerary$RouteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    where?: RouteWhereInput
    orderBy?: Enumerable<RouteOrderByWithRelationInput>
    cursor?: RouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RouteScalarFieldEnum>
  }


  /**
   * Itinerary without action
   */
  export type ItineraryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    number: string | null
    issuanceDate: string | null
    expiryDate: string | null
    issuanceCountryCode: string | null
    issuanceLocation: string | null
    nationality: string | null
    documentType: string | null
    passengerId: string | null
    holder: boolean | null
    birthPlace: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    number: string | null
    issuanceDate: string | null
    expiryDate: string | null
    issuanceCountryCode: string | null
    issuanceLocation: string | null
    nationality: string | null
    documentType: string | null
    passengerId: string | null
    holder: boolean | null
    birthPlace: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    number: number
    issuanceDate: number
    expiryDate: number
    issuanceCountryCode: number
    issuanceLocation: number
    nationality: number
    documentType: number
    passengerId: number
    holder: number
    birthPlace: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    number?: true
    issuanceDate?: true
    expiryDate?: true
    issuanceCountryCode?: true
    issuanceLocation?: true
    nationality?: true
    documentType?: true
    passengerId?: true
    holder?: true
    birthPlace?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    number?: true
    issuanceDate?: true
    expiryDate?: true
    issuanceCountryCode?: true
    issuanceLocation?: true
    nationality?: true
    documentType?: true
    passengerId?: true
    holder?: true
    birthPlace?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    number?: true
    issuanceDate?: true
    expiryDate?: true
    issuanceCountryCode?: true
    issuanceLocation?: true
    nationality?: true
    documentType?: true
    passengerId?: true
    holder?: true
    birthPlace?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    number: string | null
    issuanceDate: string | null
    expiryDate: string | null
    issuanceCountryCode: string | null
    issuanceLocation: string | null
    nationality: string | null
    documentType: string | null
    passengerId: string | null
    holder: boolean | null
    birthPlace: string | null
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    issuanceDate?: boolean
    expiryDate?: boolean
    issuanceCountryCode?: boolean
    issuanceLocation?: boolean
    nationality?: boolean
    documentType?: boolean
    passengerId?: boolean
    holder?: boolean
    birthPlace?: boolean
    Passenger?: boolean | PassengerArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    number?: boolean
    issuanceDate?: boolean
    expiryDate?: boolean
    issuanceCountryCode?: boolean
    issuanceLocation?: boolean
    nationality?: boolean
    documentType?: boolean
    passengerId?: boolean
    holder?: boolean
    birthPlace?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Passenger?: boolean | PassengerArgs<ExtArgs>
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Passenger<T extends PassengerArgs<ExtArgs> = {}>(args?: Subset<T, PassengerArgs<ExtArgs>>): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data?: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model Price
   */


  export type AggregatePrice = {
    _count: PriceCountAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  export type PriceMinAggregateOutputType = {
    id: string | null
    basePrice: string | null
    grandTotal: string | null
    discountAmt: string | null
    commissionAmt: string | null
    currency: string | null
    bookingId: string | null
  }

  export type PriceMaxAggregateOutputType = {
    id: string | null
    basePrice: string | null
    grandTotal: string | null
    discountAmt: string | null
    commissionAmt: string | null
    currency: string | null
    bookingId: string | null
  }

  export type PriceCountAggregateOutputType = {
    id: number
    basePrice: number
    grandTotal: number
    discountAmt: number
    commissionAmt: number
    currency: number
    bookingId: number
    _all: number
  }


  export type PriceMinAggregateInputType = {
    id?: true
    basePrice?: true
    grandTotal?: true
    discountAmt?: true
    commissionAmt?: true
    currency?: true
    bookingId?: true
  }

  export type PriceMaxAggregateInputType = {
    id?: true
    basePrice?: true
    grandTotal?: true
    discountAmt?: true
    commissionAmt?: true
    currency?: true
    bookingId?: true
  }

  export type PriceCountAggregateInputType = {
    id?: true
    basePrice?: true
    grandTotal?: true
    discountAmt?: true
    commissionAmt?: true
    currency?: true
    bookingId?: true
    _all?: true
  }

  export type PriceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Price to aggregate.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceMaxAggregateInputType
  }

  export type GetPriceAggregateType<T extends PriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice[P]>
      : GetScalarType<T[P], AggregatePrice[P]>
  }




  export type PriceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
    orderBy?: Enumerable<PriceOrderByWithAggregationInput>
    by: PriceScalarFieldEnum[]
    having?: PriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceCountAggregateInputType | true
    _min?: PriceMinAggregateInputType
    _max?: PriceMaxAggregateInputType
  }


  export type PriceGroupByOutputType = {
    id: string
    basePrice: string | null
    grandTotal: string | null
    discountAmt: string | null
    commissionAmt: string | null
    currency: string | null
    bookingId: string | null
    _count: PriceCountAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  type GetPriceGroupByPayload<T extends PriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basePrice?: boolean
    grandTotal?: boolean
    discountAmt?: boolean
    commissionAmt?: boolean
    currency?: boolean
    bookingId?: boolean
    Booking?: boolean | BookingArgs<ExtArgs>
    Fee?: boolean | Price$FeeArgs<ExtArgs>
    _count?: boolean | PriceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["price"]>

  export type PriceSelectScalar = {
    id?: boolean
    basePrice?: boolean
    grandTotal?: boolean
    discountAmt?: boolean
    commissionAmt?: boolean
    currency?: boolean
    bookingId?: boolean
  }

  export type PriceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingArgs<ExtArgs>
    Fee?: boolean | Price$FeeArgs<ExtArgs>
    _count?: boolean | PriceCountOutputTypeArgs<ExtArgs>
  }


  type PriceGetPayload<S extends boolean | null | undefined | PriceArgs> = $Types.GetResult<PricePayload, S>

  type PriceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PriceFindManyArgs, 'select' | 'include'> & {
      select?: PriceCountAggregateInputType | true
    }

  export interface PriceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Price'], meta: { name: 'Price' } }
    /**
     * Find zero or one Price that matches the filter.
     * @param {PriceFindUniqueArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PriceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PriceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Price'> extends True ? Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Price that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PriceFindUniqueOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PriceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PriceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PriceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Price'> extends True ? Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Price that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PriceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.price.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceWithIdOnly = await prisma.price.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PriceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PricePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Price.
     * @param {PriceCreateArgs} args - Arguments to create a Price.
     * @example
     * // Create one Price
     * const Price = await prisma.price.create({
     *   data: {
     *     // ... data to create a Price
     *   }
     * })
     * 
    **/
    create<T extends PriceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PriceCreateArgs<ExtArgs>>
    ): Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Prices.
     *     @param {PriceCreateManyArgs} args - Arguments to create many Prices.
     *     @example
     *     // Create many Prices
     *     const price = await prisma.price.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PriceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Price.
     * @param {PriceDeleteArgs} args - Arguments to delete one Price.
     * @example
     * // Delete one Price
     * const Price = await prisma.price.delete({
     *   where: {
     *     // ... filter to delete one Price
     *   }
     * })
     * 
    **/
    delete<T extends PriceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PriceDeleteArgs<ExtArgs>>
    ): Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Price.
     * @param {PriceUpdateArgs} args - Arguments to update one Price.
     * @example
     * // Update one Price
     * const price = await prisma.price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PriceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PriceUpdateArgs<ExtArgs>>
    ): Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Prices.
     * @param {PriceDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PriceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const price = await prisma.price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PriceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PriceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Price.
     * @param {PriceUpsertArgs} args - Arguments to update or create a Price.
     * @example
     * // Update or create a Price
     * const price = await prisma.price.upsert({
     *   create: {
     *     // ... data to create a Price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price we want to update
     *   }
     * })
    **/
    upsert<T extends PriceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PriceUpsertArgs<ExtArgs>>
    ): Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.price.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PriceCountArgs>(
      args?: Subset<T, PriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAggregateArgs>(args: Subset<T, PriceAggregateArgs>): Prisma.PrismaPromise<GetPriceAggregateType<T>>

    /**
     * Group by Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGroupByArgs['orderBy'] }
        : { orderBy?: PriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PriceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Booking<T extends BookingArgs<ExtArgs> = {}>(args?: Subset<T, BookingArgs<ExtArgs>>): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Fee<T extends Price$FeeArgs<ExtArgs> = {}>(args?: Subset<T, Price$FeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FeePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Price base type for findUnique actions
   */
  export type PriceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price findUnique
   */
  export interface PriceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PriceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Price findUniqueOrThrow
   */
  export type PriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }


  /**
   * Price base type for findFirst actions
   */
  export type PriceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: Enumerable<PriceScalarFieldEnum>
  }

  /**
   * Price findFirst
   */
  export interface PriceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PriceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Price findFirstOrThrow
   */
  export type PriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price findMany
   */
  export type PriceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price create
   */
  export type PriceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The data needed to create a Price.
     */
    data?: XOR<PriceCreateInput, PriceUncheckedCreateInput>
  }


  /**
   * Price createMany
   */
  export type PriceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prices.
     */
    data: Enumerable<PriceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Price update
   */
  export type PriceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The data needed to update a Price.
     */
    data: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    /**
     * Choose, which Price to update.
     */
    where: PriceWhereUniqueInput
  }


  /**
   * Price updateMany
   */
  export type PriceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prices.
     */
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PriceWhereInput
  }


  /**
   * Price upsert
   */
  export type PriceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The filter to search for the Price to update in case it exists.
     */
    where: PriceWhereUniqueInput
    /**
     * In case the Price found by the `where` argument doesn't exist, create a new Price with this data.
     */
    create: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    /**
     * In case the Price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
  }


  /**
   * Price delete
   */
  export type PriceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter which Price to delete.
     */
    where: PriceWhereUniqueInput
  }


  /**
   * Price deleteMany
   */
  export type PriceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prices to delete
     */
    where?: PriceWhereInput
  }


  /**
   * Price.Fee
   */
  export type Price$FeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    where?: FeeWhereInput
    orderBy?: Enumerable<FeeOrderByWithRelationInput>
    cursor?: FeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FeeScalarFieldEnum>
  }


  /**
   * Price without action
   */
  export type PriceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude<ExtArgs> | null
  }



  /**
   * Model Fee
   */


  export type AggregateFee = {
    _count: FeeCountAggregateOutputType | null
    _min: FeeMinAggregateOutputType | null
    _max: FeeMaxAggregateOutputType | null
  }

  export type FeeMinAggregateOutputType = {
    id: string | null
    type: string | null
    amount: string | null
    refundable: string | null
    currency: string | null
    priceId: string | null
  }

  export type FeeMaxAggregateOutputType = {
    id: string | null
    type: string | null
    amount: string | null
    refundable: string | null
    currency: string | null
    priceId: string | null
  }

  export type FeeCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    refundable: number
    currency: number
    priceId: number
    _all: number
  }


  export type FeeMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    refundable?: true
    currency?: true
    priceId?: true
  }

  export type FeeMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    refundable?: true
    currency?: true
    priceId?: true
  }

  export type FeeCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    refundable?: true
    currency?: true
    priceId?: true
    _all?: true
  }

  export type FeeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fee to aggregate.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: Enumerable<FeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fees
    **/
    _count?: true | FeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeMaxAggregateInputType
  }

  export type GetFeeAggregateType<T extends FeeAggregateArgs> = {
        [P in keyof T & keyof AggregateFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFee[P]>
      : GetScalarType<T[P], AggregateFee[P]>
  }




  export type FeeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeeWhereInput
    orderBy?: Enumerable<FeeOrderByWithAggregationInput>
    by: FeeScalarFieldEnum[]
    having?: FeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeCountAggregateInputType | true
    _min?: FeeMinAggregateInputType
    _max?: FeeMaxAggregateInputType
  }


  export type FeeGroupByOutputType = {
    id: string
    type: string | null
    amount: string | null
    refundable: string | null
    currency: string | null
    priceId: string | null
    _count: FeeCountAggregateOutputType | null
    _min: FeeMinAggregateOutputType | null
    _max: FeeMaxAggregateOutputType | null
  }

  type GetFeeGroupByPayload<T extends FeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeGroupByOutputType[P]>
            : GetScalarType<T[P], FeeGroupByOutputType[P]>
        }
      >
    >


  export type FeeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    refundable?: boolean
    currency?: boolean
    priceId?: boolean
    Price?: boolean | PriceArgs<ExtArgs>
  }, ExtArgs["result"]["fee"]>

  export type FeeSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    refundable?: boolean
    currency?: boolean
    priceId?: boolean
  }

  export type FeeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Price?: boolean | PriceArgs<ExtArgs>
  }


  type FeeGetPayload<S extends boolean | null | undefined | FeeArgs> = $Types.GetResult<FeePayload, S>

  type FeeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FeeFindManyArgs, 'select' | 'include'> & {
      select?: FeeCountAggregateInputType | true
    }

  export interface FeeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fee'], meta: { name: 'Fee' } }
    /**
     * Find zero or one Fee that matches the filter.
     * @param {FeeFindUniqueArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Fee'> extends True ? Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Fee that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeeFindUniqueOrThrowArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Fee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindFirstArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Fee'> extends True ? Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Fee that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindFirstOrThrowArgs} args - Arguments to find a Fee
     * @example
     * // Get one Fee
     * const fee = await prisma.fee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fees
     * const fees = await prisma.fee.findMany()
     * 
     * // Get first 10 Fees
     * const fees = await prisma.fee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeWithIdOnly = await prisma.fee.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<FeePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Fee.
     * @param {FeeCreateArgs} args - Arguments to create a Fee.
     * @example
     * // Create one Fee
     * const Fee = await prisma.fee.create({
     *   data: {
     *     // ... data to create a Fee
     *   }
     * })
     * 
    **/
    create<T extends FeeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeCreateArgs<ExtArgs>>
    ): Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Fees.
     *     @param {FeeCreateManyArgs} args - Arguments to create many Fees.
     *     @example
     *     // Create many Fees
     *     const fee = await prisma.fee.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fee.
     * @param {FeeDeleteArgs} args - Arguments to delete one Fee.
     * @example
     * // Delete one Fee
     * const Fee = await prisma.fee.delete({
     *   where: {
     *     // ... filter to delete one Fee
     *   }
     * })
     * 
    **/
    delete<T extends FeeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeeDeleteArgs<ExtArgs>>
    ): Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Fee.
     * @param {FeeUpdateArgs} args - Arguments to update one Fee.
     * @example
     * // Update one Fee
     * const fee = await prisma.fee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeeUpdateArgs<ExtArgs>>
    ): Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Fees.
     * @param {FeeDeleteManyArgs} args - Arguments to filter Fees to delete.
     * @example
     * // Delete a few Fees
     * const { count } = await prisma.fee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fees
     * const fee = await prisma.fee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fee.
     * @param {FeeUpsertArgs} args - Arguments to update or create a Fee.
     * @example
     * // Update or create a Fee
     * const fee = await prisma.fee.upsert({
     *   create: {
     *     // ... data to create a Fee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fee we want to update
     *   }
     * })
    **/
    upsert<T extends FeeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeeUpsertArgs<ExtArgs>>
    ): Prisma__FeeClient<$Types.GetResult<FeePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeCountArgs} args - Arguments to filter Fees to count.
     * @example
     * // Count the number of Fees
     * const count = await prisma.fee.count({
     *   where: {
     *     // ... the filter for the Fees we want to count
     *   }
     * })
    **/
    count<T extends FeeCountArgs>(
      args?: Subset<T, FeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeAggregateArgs>(args: Subset<T, FeeAggregateArgs>): Prisma.PrismaPromise<GetFeeAggregateType<T>>

    /**
     * Group by Fee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeGroupByArgs['orderBy'] }
        : { orderBy?: FeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Fee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Price<T extends PriceArgs<ExtArgs> = {}>(args?: Subset<T, PriceArgs<ExtArgs>>): Prisma__PriceClient<$Types.GetResult<PricePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Fee base type for findUnique actions
   */
  export type FeeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where: FeeWhereUniqueInput
  }

  /**
   * Fee findUnique
   */
  export interface FeeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FeeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Fee findUniqueOrThrow
   */
  export type FeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where: FeeWhereUniqueInput
  }


  /**
   * Fee base type for findFirst actions
   */
  export type FeeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: Enumerable<FeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: Enumerable<FeeScalarFieldEnum>
  }

  /**
   * Fee findFirst
   */
  export interface FeeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FeeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Fee findFirstOrThrow
   */
  export type FeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fee to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: Enumerable<FeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: Enumerable<FeeScalarFieldEnum>
  }


  /**
   * Fee findMany
   */
  export type FeeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: Enumerable<FeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fees.
     */
    cursor?: FeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    distinct?: Enumerable<FeeScalarFieldEnum>
  }


  /**
   * Fee create
   */
  export type FeeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Fee.
     */
    data?: XOR<FeeCreateInput, FeeUncheckedCreateInput>
  }


  /**
   * Fee createMany
   */
  export type FeeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fees.
     */
    data: Enumerable<FeeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Fee update
   */
  export type FeeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Fee.
     */
    data: XOR<FeeUpdateInput, FeeUncheckedUpdateInput>
    /**
     * Choose, which Fee to update.
     */
    where: FeeWhereUniqueInput
  }


  /**
   * Fee updateMany
   */
  export type FeeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fees.
     */
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeeWhereInput
  }


  /**
   * Fee upsert
   */
  export type FeeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Fee to update in case it exists.
     */
    where: FeeWhereUniqueInput
    /**
     * In case the Fee found by the `where` argument doesn't exist, create a new Fee with this data.
     */
    create: XOR<FeeCreateInput, FeeUncheckedCreateInput>
    /**
     * In case the Fee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeUpdateInput, FeeUncheckedUpdateInput>
  }


  /**
   * Fee delete
   */
  export type FeeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
    /**
     * Filter which Fee to delete.
     */
    where: FeeWhereUniqueInput
  }


  /**
   * Fee deleteMany
   */
  export type FeeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fees to delete
     */
    where?: FeeWhereInput
  }


  /**
   * Fee without action
   */
  export type FeeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fee
     */
    select?: FeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeeInclude<ExtArgs> | null
  }



  /**
   * Model Baggage
   */


  export type AggregateBaggage = {
    _count: BaggageCountAggregateOutputType | null
    _avg: BaggageAvgAggregateOutputType | null
    _sum: BaggageSumAggregateOutputType | null
    _min: BaggageMinAggregateOutputType | null
    _max: BaggageMaxAggregateOutputType | null
  }

  export type BaggageAvgAggregateOutputType = {
    quantity: number | null
  }

  export type BaggageSumAggregateOutputType = {
    quantity: number | null
  }

  export type BaggageMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    weight: string | null
    type: string | null
    passengerId: string | null
  }

  export type BaggageMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    weight: string | null
    type: string | null
    passengerId: string | null
  }

  export type BaggageCountAggregateOutputType = {
    id: number
    quantity: number
    weight: number
    type: number
    passengerId: number
    _all: number
  }


  export type BaggageAvgAggregateInputType = {
    quantity?: true
  }

  export type BaggageSumAggregateInputType = {
    quantity?: true
  }

  export type BaggageMinAggregateInputType = {
    id?: true
    quantity?: true
    weight?: true
    type?: true
    passengerId?: true
  }

  export type BaggageMaxAggregateInputType = {
    id?: true
    quantity?: true
    weight?: true
    type?: true
    passengerId?: true
  }

  export type BaggageCountAggregateInputType = {
    id?: true
    quantity?: true
    weight?: true
    type?: true
    passengerId?: true
    _all?: true
  }

  export type BaggageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Baggage to aggregate.
     */
    where?: BaggageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baggages to fetch.
     */
    orderBy?: Enumerable<BaggageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaggageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baggages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baggages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Baggages
    **/
    _count?: true | BaggageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaggageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaggageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaggageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaggageMaxAggregateInputType
  }

  export type GetBaggageAggregateType<T extends BaggageAggregateArgs> = {
        [P in keyof T & keyof AggregateBaggage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaggage[P]>
      : GetScalarType<T[P], AggregateBaggage[P]>
  }




  export type BaggageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BaggageWhereInput
    orderBy?: Enumerable<BaggageOrderByWithAggregationInput>
    by: BaggageScalarFieldEnum[]
    having?: BaggageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaggageCountAggregateInputType | true
    _avg?: BaggageAvgAggregateInputType
    _sum?: BaggageSumAggregateInputType
    _min?: BaggageMinAggregateInputType
    _max?: BaggageMaxAggregateInputType
  }


  export type BaggageGroupByOutputType = {
    id: string
    quantity: number | null
    weight: string | null
    type: string | null
    passengerId: string | null
    _count: BaggageCountAggregateOutputType | null
    _avg: BaggageAvgAggregateOutputType | null
    _sum: BaggageSumAggregateOutputType | null
    _min: BaggageMinAggregateOutputType | null
    _max: BaggageMaxAggregateOutputType | null
  }

  type GetBaggageGroupByPayload<T extends BaggageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BaggageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaggageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaggageGroupByOutputType[P]>
            : GetScalarType<T[P], BaggageGroupByOutputType[P]>
        }
      >
    >


  export type BaggageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    weight?: boolean
    type?: boolean
    passengerId?: boolean
    Passenger?: boolean | PassengerArgs<ExtArgs>
  }, ExtArgs["result"]["baggage"]>

  export type BaggageSelectScalar = {
    id?: boolean
    quantity?: boolean
    weight?: boolean
    type?: boolean
    passengerId?: boolean
  }

  export type BaggageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Passenger?: boolean | PassengerArgs<ExtArgs>
  }


  type BaggageGetPayload<S extends boolean | null | undefined | BaggageArgs> = $Types.GetResult<BaggagePayload, S>

  type BaggageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BaggageFindManyArgs, 'select' | 'include'> & {
      select?: BaggageCountAggregateInputType | true
    }

  export interface BaggageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Baggage'], meta: { name: 'Baggage' } }
    /**
     * Find zero or one Baggage that matches the filter.
     * @param {BaggageFindUniqueArgs} args - Arguments to find a Baggage
     * @example
     * // Get one Baggage
     * const baggage = await prisma.baggage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BaggageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BaggageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Baggage'> extends True ? Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Baggage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BaggageFindUniqueOrThrowArgs} args - Arguments to find a Baggage
     * @example
     * // Get one Baggage
     * const baggage = await prisma.baggage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BaggageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BaggageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Baggage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaggageFindFirstArgs} args - Arguments to find a Baggage
     * @example
     * // Get one Baggage
     * const baggage = await prisma.baggage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BaggageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BaggageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Baggage'> extends True ? Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Baggage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaggageFindFirstOrThrowArgs} args - Arguments to find a Baggage
     * @example
     * // Get one Baggage
     * const baggage = await prisma.baggage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BaggageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BaggageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Baggages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaggageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Baggages
     * const baggages = await prisma.baggage.findMany()
     * 
     * // Get first 10 Baggages
     * const baggages = await prisma.baggage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baggageWithIdOnly = await prisma.baggage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BaggageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BaggageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Baggage.
     * @param {BaggageCreateArgs} args - Arguments to create a Baggage.
     * @example
     * // Create one Baggage
     * const Baggage = await prisma.baggage.create({
     *   data: {
     *     // ... data to create a Baggage
     *   }
     * })
     * 
    **/
    create<T extends BaggageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BaggageCreateArgs<ExtArgs>>
    ): Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Baggages.
     *     @param {BaggageCreateManyArgs} args - Arguments to create many Baggages.
     *     @example
     *     // Create many Baggages
     *     const baggage = await prisma.baggage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BaggageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BaggageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Baggage.
     * @param {BaggageDeleteArgs} args - Arguments to delete one Baggage.
     * @example
     * // Delete one Baggage
     * const Baggage = await prisma.baggage.delete({
     *   where: {
     *     // ... filter to delete one Baggage
     *   }
     * })
     * 
    **/
    delete<T extends BaggageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BaggageDeleteArgs<ExtArgs>>
    ): Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Baggage.
     * @param {BaggageUpdateArgs} args - Arguments to update one Baggage.
     * @example
     * // Update one Baggage
     * const baggage = await prisma.baggage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BaggageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BaggageUpdateArgs<ExtArgs>>
    ): Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Baggages.
     * @param {BaggageDeleteManyArgs} args - Arguments to filter Baggages to delete.
     * @example
     * // Delete a few Baggages
     * const { count } = await prisma.baggage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BaggageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BaggageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Baggages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaggageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Baggages
     * const baggage = await prisma.baggage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BaggageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BaggageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Baggage.
     * @param {BaggageUpsertArgs} args - Arguments to update or create a Baggage.
     * @example
     * // Update or create a Baggage
     * const baggage = await prisma.baggage.upsert({
     *   create: {
     *     // ... data to create a Baggage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Baggage we want to update
     *   }
     * })
    **/
    upsert<T extends BaggageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BaggageUpsertArgs<ExtArgs>>
    ): Prisma__BaggageClient<$Types.GetResult<BaggagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Baggages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaggageCountArgs} args - Arguments to filter Baggages to count.
     * @example
     * // Count the number of Baggages
     * const count = await prisma.baggage.count({
     *   where: {
     *     // ... the filter for the Baggages we want to count
     *   }
     * })
    **/
    count<T extends BaggageCountArgs>(
      args?: Subset<T, BaggageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaggageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Baggage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaggageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaggageAggregateArgs>(args: Subset<T, BaggageAggregateArgs>): Prisma.PrismaPromise<GetBaggageAggregateType<T>>

    /**
     * Group by Baggage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaggageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaggageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaggageGroupByArgs['orderBy'] }
        : { orderBy?: BaggageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaggageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaggageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Baggage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BaggageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Passenger<T extends PassengerArgs<ExtArgs> = {}>(args?: Subset<T, PassengerArgs<ExtArgs>>): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Baggage base type for findUnique actions
   */
  export type BaggageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * Filter, which Baggage to fetch.
     */
    where: BaggageWhereUniqueInput
  }

  /**
   * Baggage findUnique
   */
  export interface BaggageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BaggageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Baggage findUniqueOrThrow
   */
  export type BaggageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * Filter, which Baggage to fetch.
     */
    where: BaggageWhereUniqueInput
  }


  /**
   * Baggage base type for findFirst actions
   */
  export type BaggageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * Filter, which Baggage to fetch.
     */
    where?: BaggageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baggages to fetch.
     */
    orderBy?: Enumerable<BaggageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Baggages.
     */
    cursor?: BaggageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baggages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baggages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Baggages.
     */
    distinct?: Enumerable<BaggageScalarFieldEnum>
  }

  /**
   * Baggage findFirst
   */
  export interface BaggageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BaggageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Baggage findFirstOrThrow
   */
  export type BaggageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * Filter, which Baggage to fetch.
     */
    where?: BaggageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baggages to fetch.
     */
    orderBy?: Enumerable<BaggageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Baggages.
     */
    cursor?: BaggageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baggages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baggages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Baggages.
     */
    distinct?: Enumerable<BaggageScalarFieldEnum>
  }


  /**
   * Baggage findMany
   */
  export type BaggageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * Filter, which Baggages to fetch.
     */
    where?: BaggageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baggages to fetch.
     */
    orderBy?: Enumerable<BaggageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Baggages.
     */
    cursor?: BaggageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baggages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baggages.
     */
    skip?: number
    distinct?: Enumerable<BaggageScalarFieldEnum>
  }


  /**
   * Baggage create
   */
  export type BaggageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * The data needed to create a Baggage.
     */
    data?: XOR<BaggageCreateInput, BaggageUncheckedCreateInput>
  }


  /**
   * Baggage createMany
   */
  export type BaggageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Baggages.
     */
    data: Enumerable<BaggageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Baggage update
   */
  export type BaggageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * The data needed to update a Baggage.
     */
    data: XOR<BaggageUpdateInput, BaggageUncheckedUpdateInput>
    /**
     * Choose, which Baggage to update.
     */
    where: BaggageWhereUniqueInput
  }


  /**
   * Baggage updateMany
   */
  export type BaggageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Baggages.
     */
    data: XOR<BaggageUpdateManyMutationInput, BaggageUncheckedUpdateManyInput>
    /**
     * Filter which Baggages to update
     */
    where?: BaggageWhereInput
  }


  /**
   * Baggage upsert
   */
  export type BaggageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * The filter to search for the Baggage to update in case it exists.
     */
    where: BaggageWhereUniqueInput
    /**
     * In case the Baggage found by the `where` argument doesn't exist, create a new Baggage with this data.
     */
    create: XOR<BaggageCreateInput, BaggageUncheckedCreateInput>
    /**
     * In case the Baggage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaggageUpdateInput, BaggageUncheckedUpdateInput>
  }


  /**
   * Baggage delete
   */
  export type BaggageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
    /**
     * Filter which Baggage to delete.
     */
    where: BaggageWhereUniqueInput
  }


  /**
   * Baggage deleteMany
   */
  export type BaggageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Baggages to delete
     */
    where?: BaggageWhereInput
  }


  /**
   * Baggage without action
   */
  export type BaggageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baggage
     */
    select?: BaggageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BaggageInclude<ExtArgs> | null
  }



  /**
   * Model Route
   */


  export type AggregateRoute = {
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  export type RouteAvgAggregateOutputType = {
    numberOfStops: number | null
  }

  export type RouteSumAggregateOutputType = {
    numberOfStops: number | null
  }

  export type RouteMinAggregateOutputType = {
    id: string | null
    departIataCode: string | null
    departTerminal: string | null
    departAt: string | null
    arrivalIataCode: string | null
    arrivalTerminal: string | null
    arrivalAt: string | null
    flightNumber: string | null
    aircraftCode: string | null
    duration: string | null
    numberOfStops: number | null
    carrierCode: string | null
    routeId: string | null
    itineraryId: string | null
  }

  export type RouteMaxAggregateOutputType = {
    id: string | null
    departIataCode: string | null
    departTerminal: string | null
    departAt: string | null
    arrivalIataCode: string | null
    arrivalTerminal: string | null
    arrivalAt: string | null
    flightNumber: string | null
    aircraftCode: string | null
    duration: string | null
    numberOfStops: number | null
    carrierCode: string | null
    routeId: string | null
    itineraryId: string | null
  }

  export type RouteCountAggregateOutputType = {
    id: number
    departIataCode: number
    departTerminal: number
    departAt: number
    arrivalIataCode: number
    arrivalTerminal: number
    arrivalAt: number
    flightNumber: number
    aircraftCode: number
    duration: number
    numberOfStops: number
    carrierCode: number
    routeId: number
    itineraryId: number
    _all: number
  }


  export type RouteAvgAggregateInputType = {
    numberOfStops?: true
  }

  export type RouteSumAggregateInputType = {
    numberOfStops?: true
  }

  export type RouteMinAggregateInputType = {
    id?: true
    departIataCode?: true
    departTerminal?: true
    departAt?: true
    arrivalIataCode?: true
    arrivalTerminal?: true
    arrivalAt?: true
    flightNumber?: true
    aircraftCode?: true
    duration?: true
    numberOfStops?: true
    carrierCode?: true
    routeId?: true
    itineraryId?: true
  }

  export type RouteMaxAggregateInputType = {
    id?: true
    departIataCode?: true
    departTerminal?: true
    departAt?: true
    arrivalIataCode?: true
    arrivalTerminal?: true
    arrivalAt?: true
    flightNumber?: true
    aircraftCode?: true
    duration?: true
    numberOfStops?: true
    carrierCode?: true
    routeId?: true
    itineraryId?: true
  }

  export type RouteCountAggregateInputType = {
    id?: true
    departIataCode?: true
    departTerminal?: true
    departAt?: true
    arrivalIataCode?: true
    arrivalTerminal?: true
    arrivalAt?: true
    flightNumber?: true
    aircraftCode?: true
    duration?: true
    numberOfStops?: true
    carrierCode?: true
    routeId?: true
    itineraryId?: true
    _all?: true
  }

  export type RouteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Route to aggregate.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: Enumerable<RouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routes
    **/
    _count?: true | RouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMaxAggregateInputType
  }

  export type GetRouteAggregateType<T extends RouteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute[P]>
      : GetScalarType<T[P], AggregateRoute[P]>
  }




  export type RouteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
    orderBy?: Enumerable<RouteOrderByWithAggregationInput>
    by: RouteScalarFieldEnum[]
    having?: RouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCountAggregateInputType | true
    _avg?: RouteAvgAggregateInputType
    _sum?: RouteSumAggregateInputType
    _min?: RouteMinAggregateInputType
    _max?: RouteMaxAggregateInputType
  }


  export type RouteGroupByOutputType = {
    id: string
    departIataCode: string | null
    departTerminal: string | null
    departAt: string | null
    arrivalIataCode: string | null
    arrivalTerminal: string | null
    arrivalAt: string | null
    flightNumber: string | null
    aircraftCode: string | null
    duration: string | null
    numberOfStops: number | null
    carrierCode: string | null
    routeId: string | null
    itineraryId: string | null
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  type GetRouteGroupByPayload<T extends RouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteGroupByOutputType[P]>
            : GetScalarType<T[P], RouteGroupByOutputType[P]>
        }
      >
    >


  export type RouteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departIataCode?: boolean
    departTerminal?: boolean
    departAt?: boolean
    arrivalIataCode?: boolean
    arrivalTerminal?: boolean
    arrivalAt?: boolean
    flightNumber?: boolean
    aircraftCode?: boolean
    duration?: boolean
    numberOfStops?: boolean
    carrierCode?: boolean
    routeId?: boolean
    itineraryId?: boolean
    Itinerary?: boolean | ItineraryArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>

  export type RouteSelectScalar = {
    id?: boolean
    departIataCode?: boolean
    departTerminal?: boolean
    departAt?: boolean
    arrivalIataCode?: boolean
    arrivalTerminal?: boolean
    arrivalAt?: boolean
    flightNumber?: boolean
    aircraftCode?: boolean
    duration?: boolean
    numberOfStops?: boolean
    carrierCode?: boolean
    routeId?: boolean
    itineraryId?: boolean
  }

  export type RouteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Itinerary?: boolean | ItineraryArgs<ExtArgs>
  }


  type RouteGetPayload<S extends boolean | null | undefined | RouteArgs> = $Types.GetResult<RoutePayload, S>

  type RouteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RouteFindManyArgs, 'select' | 'include'> & {
      select?: RouteCountAggregateInputType | true
    }

  export interface RouteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Route'], meta: { name: 'Route' } }
    /**
     * Find zero or one Route that matches the filter.
     * @param {RouteFindUniqueArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RouteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RouteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Route'> extends True ? Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Route that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RouteFindUniqueOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RouteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RouteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Route that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RouteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RouteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Route'> extends True ? Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Route that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RouteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RouteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Routes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routes
     * const routes = await prisma.route.findMany()
     * 
     * // Get first 10 Routes
     * const routes = await prisma.route.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeWithIdOnly = await prisma.route.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RouteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RouteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RoutePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Route.
     * @param {RouteCreateArgs} args - Arguments to create a Route.
     * @example
     * // Create one Route
     * const Route = await prisma.route.create({
     *   data: {
     *     // ... data to create a Route
     *   }
     * })
     * 
    **/
    create<T extends RouteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RouteCreateArgs<ExtArgs>>
    ): Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Routes.
     *     @param {RouteCreateManyArgs} args - Arguments to create many Routes.
     *     @example
     *     // Create many Routes
     *     const route = await prisma.route.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RouteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RouteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Route.
     * @param {RouteDeleteArgs} args - Arguments to delete one Route.
     * @example
     * // Delete one Route
     * const Route = await prisma.route.delete({
     *   where: {
     *     // ... filter to delete one Route
     *   }
     * })
     * 
    **/
    delete<T extends RouteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RouteDeleteArgs<ExtArgs>>
    ): Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Route.
     * @param {RouteUpdateArgs} args - Arguments to update one Route.
     * @example
     * // Update one Route
     * const route = await prisma.route.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RouteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RouteUpdateArgs<ExtArgs>>
    ): Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Routes.
     * @param {RouteDeleteManyArgs} args - Arguments to filter Routes to delete.
     * @example
     * // Delete a few Routes
     * const { count } = await prisma.route.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RouteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RouteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RouteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RouteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Route.
     * @param {RouteUpsertArgs} args - Arguments to update or create a Route.
     * @example
     * // Update or create a Route
     * const route = await prisma.route.upsert({
     *   create: {
     *     // ... data to create a Route
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route we want to update
     *   }
     * })
    **/
    upsert<T extends RouteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RouteUpsertArgs<ExtArgs>>
    ): Prisma__RouteClient<$Types.GetResult<RoutePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCountArgs} args - Arguments to filter Routes to count.
     * @example
     * // Count the number of Routes
     * const count = await prisma.route.count({
     *   where: {
     *     // ... the filter for the Routes we want to count
     *   }
     * })
    **/
    count<T extends RouteCountArgs>(
      args?: Subset<T, RouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAggregateArgs>(args: Subset<T, RouteAggregateArgs>): Prisma.PrismaPromise<GetRouteAggregateType<T>>

    /**
     * Group by Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteGroupByArgs['orderBy'] }
        : { orderBy?: RouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Route.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RouteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Itinerary<T extends ItineraryArgs<ExtArgs> = {}>(args?: Subset<T, ItineraryArgs<ExtArgs>>): Prisma__ItineraryClient<$Types.GetResult<ItineraryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Route base type for findUnique actions
   */
  export type RouteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findUnique
   */
  export interface RouteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RouteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Route findUniqueOrThrow
   */
  export type RouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }


  /**
   * Route base type for findFirst actions
   */
  export type RouteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: Enumerable<RouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: Enumerable<RouteScalarFieldEnum>
  }

  /**
   * Route findFirst
   */
  export interface RouteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RouteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Route findFirstOrThrow
   */
  export type RouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: Enumerable<RouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: Enumerable<RouteScalarFieldEnum>
  }


  /**
   * Route findMany
   */
  export type RouteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Routes to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: Enumerable<RouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    distinct?: Enumerable<RouteScalarFieldEnum>
  }


  /**
   * Route create
   */
  export type RouteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to create a Route.
     */
    data?: XOR<RouteCreateInput, RouteUncheckedCreateInput>
  }


  /**
   * Route createMany
   */
  export type RouteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routes.
     */
    data: Enumerable<RouteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Route update
   */
  export type RouteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to update a Route.
     */
    data: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
    /**
     * Choose, which Route to update.
     */
    where: RouteWhereUniqueInput
  }


  /**
   * Route updateMany
   */
  export type RouteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
  }


  /**
   * Route upsert
   */
  export type RouteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The filter to search for the Route to update in case it exists.
     */
    where: RouteWhereUniqueInput
    /**
     * In case the Route found by the `where` argument doesn't exist, create a new Route with this data.
     */
    create: XOR<RouteCreateInput, RouteUncheckedCreateInput>
    /**
     * In case the Route was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
  }


  /**
   * Route delete
   */
  export type RouteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter which Route to delete.
     */
    where: RouteWhereUniqueInput
  }


  /**
   * Route deleteMany
   */
  export type RouteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routes to delete
     */
    where?: RouteWhereInput
  }


  /**
   * Route without action
   */
  export type RouteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RouteInclude<ExtArgs> | null
  }



  /**
   * Model fareDetailsByRoute
   */


  export type AggregateFareDetailsByRoute = {
    _count: FareDetailsByRouteCountAggregateOutputType | null
    _avg: FareDetailsByRouteAvgAggregateOutputType | null
    _sum: FareDetailsByRouteSumAggregateOutputType | null
    _min: FareDetailsByRouteMinAggregateOutputType | null
    _max: FareDetailsByRouteMaxAggregateOutputType | null
  }

  export type FareDetailsByRouteAvgAggregateOutputType = {
    includedCheckedBagsUnit: number | null
    includedCheckedBagsWeight: number | null
  }

  export type FareDetailsByRouteSumAggregateOutputType = {
    includedCheckedBagsUnit: number | null
    includedCheckedBagsWeight: number | null
  }

  export type FareDetailsByRouteMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    fareBasis: string | null
    class: string | null
    brandedFare: string | null
    includedCheckedBagsUnit: number | null
    includedCheckedBagsWeight: number | null
    includedCheckedBagsWeightUnit: string | null
    cabin: string | null
    passengerId: string | null
  }

  export type FareDetailsByRouteMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    fareBasis: string | null
    class: string | null
    brandedFare: string | null
    includedCheckedBagsUnit: number | null
    includedCheckedBagsWeight: number | null
    includedCheckedBagsWeightUnit: string | null
    cabin: string | null
    passengerId: string | null
  }

  export type FareDetailsByRouteCountAggregateOutputType = {
    id: number
    routeId: number
    fareBasis: number
    class: number
    brandedFare: number
    includedCheckedBagsUnit: number
    includedCheckedBagsWeight: number
    includedCheckedBagsWeightUnit: number
    cabin: number
    passengerId: number
    _all: number
  }


  export type FareDetailsByRouteAvgAggregateInputType = {
    includedCheckedBagsUnit?: true
    includedCheckedBagsWeight?: true
  }

  export type FareDetailsByRouteSumAggregateInputType = {
    includedCheckedBagsUnit?: true
    includedCheckedBagsWeight?: true
  }

  export type FareDetailsByRouteMinAggregateInputType = {
    id?: true
    routeId?: true
    fareBasis?: true
    class?: true
    brandedFare?: true
    includedCheckedBagsUnit?: true
    includedCheckedBagsWeight?: true
    includedCheckedBagsWeightUnit?: true
    cabin?: true
    passengerId?: true
  }

  export type FareDetailsByRouteMaxAggregateInputType = {
    id?: true
    routeId?: true
    fareBasis?: true
    class?: true
    brandedFare?: true
    includedCheckedBagsUnit?: true
    includedCheckedBagsWeight?: true
    includedCheckedBagsWeightUnit?: true
    cabin?: true
    passengerId?: true
  }

  export type FareDetailsByRouteCountAggregateInputType = {
    id?: true
    routeId?: true
    fareBasis?: true
    class?: true
    brandedFare?: true
    includedCheckedBagsUnit?: true
    includedCheckedBagsWeight?: true
    includedCheckedBagsWeightUnit?: true
    cabin?: true
    passengerId?: true
    _all?: true
  }

  export type FareDetailsByRouteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fareDetailsByRoute to aggregate.
     */
    where?: fareDetailsByRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fareDetailsByRoutes to fetch.
     */
    orderBy?: Enumerable<fareDetailsByRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fareDetailsByRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fareDetailsByRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fareDetailsByRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fareDetailsByRoutes
    **/
    _count?: true | FareDetailsByRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FareDetailsByRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FareDetailsByRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FareDetailsByRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FareDetailsByRouteMaxAggregateInputType
  }

  export type GetFareDetailsByRouteAggregateType<T extends FareDetailsByRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateFareDetailsByRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFareDetailsByRoute[P]>
      : GetScalarType<T[P], AggregateFareDetailsByRoute[P]>
  }




  export type FareDetailsByRouteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fareDetailsByRouteWhereInput
    orderBy?: Enumerable<fareDetailsByRouteOrderByWithAggregationInput>
    by: FareDetailsByRouteScalarFieldEnum[]
    having?: fareDetailsByRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FareDetailsByRouteCountAggregateInputType | true
    _avg?: FareDetailsByRouteAvgAggregateInputType
    _sum?: FareDetailsByRouteSumAggregateInputType
    _min?: FareDetailsByRouteMinAggregateInputType
    _max?: FareDetailsByRouteMaxAggregateInputType
  }


  export type FareDetailsByRouteGroupByOutputType = {
    id: string
    routeId: string | null
    fareBasis: string | null
    class: string | null
    brandedFare: string | null
    includedCheckedBagsUnit: number | null
    includedCheckedBagsWeight: number | null
    includedCheckedBagsWeightUnit: string | null
    cabin: string | null
    passengerId: string | null
    _count: FareDetailsByRouteCountAggregateOutputType | null
    _avg: FareDetailsByRouteAvgAggregateOutputType | null
    _sum: FareDetailsByRouteSumAggregateOutputType | null
    _min: FareDetailsByRouteMinAggregateOutputType | null
    _max: FareDetailsByRouteMaxAggregateOutputType | null
  }

  type GetFareDetailsByRouteGroupByPayload<T extends FareDetailsByRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FareDetailsByRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FareDetailsByRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FareDetailsByRouteGroupByOutputType[P]>
            : GetScalarType<T[P], FareDetailsByRouteGroupByOutputType[P]>
        }
      >
    >


  export type fareDetailsByRouteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    fareBasis?: boolean
    class?: boolean
    brandedFare?: boolean
    includedCheckedBagsUnit?: boolean
    includedCheckedBagsWeight?: boolean
    includedCheckedBagsWeightUnit?: boolean
    cabin?: boolean
    passengerId?: boolean
    Passenger?: boolean | PassengerArgs<ExtArgs>
  }, ExtArgs["result"]["fareDetailsByRoute"]>

  export type fareDetailsByRouteSelectScalar = {
    id?: boolean
    routeId?: boolean
    fareBasis?: boolean
    class?: boolean
    brandedFare?: boolean
    includedCheckedBagsUnit?: boolean
    includedCheckedBagsWeight?: boolean
    includedCheckedBagsWeightUnit?: boolean
    cabin?: boolean
    passengerId?: boolean
  }

  export type fareDetailsByRouteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Passenger?: boolean | PassengerArgs<ExtArgs>
  }


  type fareDetailsByRouteGetPayload<S extends boolean | null | undefined | fareDetailsByRouteArgs> = $Types.GetResult<fareDetailsByRoutePayload, S>

  type fareDetailsByRouteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fareDetailsByRouteFindManyArgs, 'select' | 'include'> & {
      select?: FareDetailsByRouteCountAggregateInputType | true
    }

  export interface fareDetailsByRouteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fareDetailsByRoute'], meta: { name: 'fareDetailsByRoute' } }
    /**
     * Find zero or one FareDetailsByRoute that matches the filter.
     * @param {fareDetailsByRouteFindUniqueArgs} args - Arguments to find a FareDetailsByRoute
     * @example
     * // Get one FareDetailsByRoute
     * const fareDetailsByRoute = await prisma.fareDetailsByRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fareDetailsByRouteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fareDetailsByRouteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fareDetailsByRoute'> extends True ? Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one FareDetailsByRoute that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fareDetailsByRouteFindUniqueOrThrowArgs} args - Arguments to find a FareDetailsByRoute
     * @example
     * // Get one FareDetailsByRoute
     * const fareDetailsByRoute = await prisma.fareDetailsByRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fareDetailsByRouteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fareDetailsByRouteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first FareDetailsByRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fareDetailsByRouteFindFirstArgs} args - Arguments to find a FareDetailsByRoute
     * @example
     * // Get one FareDetailsByRoute
     * const fareDetailsByRoute = await prisma.fareDetailsByRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fareDetailsByRouteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fareDetailsByRouteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fareDetailsByRoute'> extends True ? Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first FareDetailsByRoute that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fareDetailsByRouteFindFirstOrThrowArgs} args - Arguments to find a FareDetailsByRoute
     * @example
     * // Get one FareDetailsByRoute
     * const fareDetailsByRoute = await prisma.fareDetailsByRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fareDetailsByRouteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fareDetailsByRouteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more FareDetailsByRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fareDetailsByRouteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FareDetailsByRoutes
     * const fareDetailsByRoutes = await prisma.fareDetailsByRoute.findMany()
     * 
     * // Get first 10 FareDetailsByRoutes
     * const fareDetailsByRoutes = await prisma.fareDetailsByRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fareDetailsByRouteWithIdOnly = await prisma.fareDetailsByRoute.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fareDetailsByRouteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fareDetailsByRouteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a FareDetailsByRoute.
     * @param {fareDetailsByRouteCreateArgs} args - Arguments to create a FareDetailsByRoute.
     * @example
     * // Create one FareDetailsByRoute
     * const FareDetailsByRoute = await prisma.fareDetailsByRoute.create({
     *   data: {
     *     // ... data to create a FareDetailsByRoute
     *   }
     * })
     * 
    **/
    create<T extends fareDetailsByRouteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fareDetailsByRouteCreateArgs<ExtArgs>>
    ): Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many FareDetailsByRoutes.
     *     @param {fareDetailsByRouteCreateManyArgs} args - Arguments to create many FareDetailsByRoutes.
     *     @example
     *     // Create many FareDetailsByRoutes
     *     const fareDetailsByRoute = await prisma.fareDetailsByRoute.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fareDetailsByRouteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fareDetailsByRouteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FareDetailsByRoute.
     * @param {fareDetailsByRouteDeleteArgs} args - Arguments to delete one FareDetailsByRoute.
     * @example
     * // Delete one FareDetailsByRoute
     * const FareDetailsByRoute = await prisma.fareDetailsByRoute.delete({
     *   where: {
     *     // ... filter to delete one FareDetailsByRoute
     *   }
     * })
     * 
    **/
    delete<T extends fareDetailsByRouteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fareDetailsByRouteDeleteArgs<ExtArgs>>
    ): Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one FareDetailsByRoute.
     * @param {fareDetailsByRouteUpdateArgs} args - Arguments to update one FareDetailsByRoute.
     * @example
     * // Update one FareDetailsByRoute
     * const fareDetailsByRoute = await prisma.fareDetailsByRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fareDetailsByRouteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fareDetailsByRouteUpdateArgs<ExtArgs>>
    ): Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more FareDetailsByRoutes.
     * @param {fareDetailsByRouteDeleteManyArgs} args - Arguments to filter FareDetailsByRoutes to delete.
     * @example
     * // Delete a few FareDetailsByRoutes
     * const { count } = await prisma.fareDetailsByRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fareDetailsByRouteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fareDetailsByRouteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FareDetailsByRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fareDetailsByRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FareDetailsByRoutes
     * const fareDetailsByRoute = await prisma.fareDetailsByRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fareDetailsByRouteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fareDetailsByRouteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FareDetailsByRoute.
     * @param {fareDetailsByRouteUpsertArgs} args - Arguments to update or create a FareDetailsByRoute.
     * @example
     * // Update or create a FareDetailsByRoute
     * const fareDetailsByRoute = await prisma.fareDetailsByRoute.upsert({
     *   create: {
     *     // ... data to create a FareDetailsByRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FareDetailsByRoute we want to update
     *   }
     * })
    **/
    upsert<T extends fareDetailsByRouteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fareDetailsByRouteUpsertArgs<ExtArgs>>
    ): Prisma__fareDetailsByRouteClient<$Types.GetResult<fareDetailsByRoutePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of FareDetailsByRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fareDetailsByRouteCountArgs} args - Arguments to filter FareDetailsByRoutes to count.
     * @example
     * // Count the number of FareDetailsByRoutes
     * const count = await prisma.fareDetailsByRoute.count({
     *   where: {
     *     // ... the filter for the FareDetailsByRoutes we want to count
     *   }
     * })
    **/
    count<T extends fareDetailsByRouteCountArgs>(
      args?: Subset<T, fareDetailsByRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FareDetailsByRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FareDetailsByRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareDetailsByRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FareDetailsByRouteAggregateArgs>(args: Subset<T, FareDetailsByRouteAggregateArgs>): Prisma.PrismaPromise<GetFareDetailsByRouteAggregateType<T>>

    /**
     * Group by FareDetailsByRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareDetailsByRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FareDetailsByRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FareDetailsByRouteGroupByArgs['orderBy'] }
        : { orderBy?: FareDetailsByRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FareDetailsByRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFareDetailsByRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fareDetailsByRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fareDetailsByRouteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Passenger<T extends PassengerArgs<ExtArgs> = {}>(args?: Subset<T, PassengerArgs<ExtArgs>>): Prisma__PassengerClient<$Types.GetResult<PassengerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fareDetailsByRoute base type for findUnique actions
   */
  export type fareDetailsByRouteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * Filter, which fareDetailsByRoute to fetch.
     */
    where: fareDetailsByRouteWhereUniqueInput
  }

  /**
   * fareDetailsByRoute findUnique
   */
  export interface fareDetailsByRouteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fareDetailsByRouteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fareDetailsByRoute findUniqueOrThrow
   */
  export type fareDetailsByRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * Filter, which fareDetailsByRoute to fetch.
     */
    where: fareDetailsByRouteWhereUniqueInput
  }


  /**
   * fareDetailsByRoute base type for findFirst actions
   */
  export type fareDetailsByRouteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * Filter, which fareDetailsByRoute to fetch.
     */
    where?: fareDetailsByRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fareDetailsByRoutes to fetch.
     */
    orderBy?: Enumerable<fareDetailsByRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fareDetailsByRoutes.
     */
    cursor?: fareDetailsByRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fareDetailsByRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fareDetailsByRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fareDetailsByRoutes.
     */
    distinct?: Enumerable<FareDetailsByRouteScalarFieldEnum>
  }

  /**
   * fareDetailsByRoute findFirst
   */
  export interface fareDetailsByRouteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fareDetailsByRouteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fareDetailsByRoute findFirstOrThrow
   */
  export type fareDetailsByRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * Filter, which fareDetailsByRoute to fetch.
     */
    where?: fareDetailsByRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fareDetailsByRoutes to fetch.
     */
    orderBy?: Enumerable<fareDetailsByRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fareDetailsByRoutes.
     */
    cursor?: fareDetailsByRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fareDetailsByRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fareDetailsByRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fareDetailsByRoutes.
     */
    distinct?: Enumerable<FareDetailsByRouteScalarFieldEnum>
  }


  /**
   * fareDetailsByRoute findMany
   */
  export type fareDetailsByRouteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * Filter, which fareDetailsByRoutes to fetch.
     */
    where?: fareDetailsByRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fareDetailsByRoutes to fetch.
     */
    orderBy?: Enumerable<fareDetailsByRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fareDetailsByRoutes.
     */
    cursor?: fareDetailsByRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fareDetailsByRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fareDetailsByRoutes.
     */
    skip?: number
    distinct?: Enumerable<FareDetailsByRouteScalarFieldEnum>
  }


  /**
   * fareDetailsByRoute create
   */
  export type fareDetailsByRouteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a fareDetailsByRoute.
     */
    data?: XOR<fareDetailsByRouteCreateInput, fareDetailsByRouteUncheckedCreateInput>
  }


  /**
   * fareDetailsByRoute createMany
   */
  export type fareDetailsByRouteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fareDetailsByRoutes.
     */
    data: Enumerable<fareDetailsByRouteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fareDetailsByRoute update
   */
  export type fareDetailsByRouteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a fareDetailsByRoute.
     */
    data: XOR<fareDetailsByRouteUpdateInput, fareDetailsByRouteUncheckedUpdateInput>
    /**
     * Choose, which fareDetailsByRoute to update.
     */
    where: fareDetailsByRouteWhereUniqueInput
  }


  /**
   * fareDetailsByRoute updateMany
   */
  export type fareDetailsByRouteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fareDetailsByRoutes.
     */
    data: XOR<fareDetailsByRouteUpdateManyMutationInput, fareDetailsByRouteUncheckedUpdateManyInput>
    /**
     * Filter which fareDetailsByRoutes to update
     */
    where?: fareDetailsByRouteWhereInput
  }


  /**
   * fareDetailsByRoute upsert
   */
  export type fareDetailsByRouteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the fareDetailsByRoute to update in case it exists.
     */
    where: fareDetailsByRouteWhereUniqueInput
    /**
     * In case the fareDetailsByRoute found by the `where` argument doesn't exist, create a new fareDetailsByRoute with this data.
     */
    create: XOR<fareDetailsByRouteCreateInput, fareDetailsByRouteUncheckedCreateInput>
    /**
     * In case the fareDetailsByRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fareDetailsByRouteUpdateInput, fareDetailsByRouteUncheckedUpdateInput>
  }


  /**
   * fareDetailsByRoute delete
   */
  export type fareDetailsByRouteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
    /**
     * Filter which fareDetailsByRoute to delete.
     */
    where: fareDetailsByRouteWhereUniqueInput
  }


  /**
   * fareDetailsByRoute deleteMany
   */
  export type fareDetailsByRouteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fareDetailsByRoutes to delete
     */
    where?: fareDetailsByRouteWhereInput
  }


  /**
   * fareDetailsByRoute without action
   */
  export type fareDetailsByRouteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fareDetailsByRoute
     */
    select?: fareDetailsByRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fareDetailsByRouteInclude<ExtArgs> | null
  }



  /**
   * Model Users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    accesstoken: string | null
    refreshtoken: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    accesstoken: string | null
    refreshtoken: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    accesstoken: number
    refreshtoken: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    accesstoken?: true
    refreshtoken?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    accesstoken?: true
    refreshtoken?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    accesstoken?: true
    refreshtoken?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: Enumerable<UsersOrderByWithAggregationInput>
    by: UsersScalarFieldEnum[]
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    password: string | null
    accesstoken: string | null
    refreshtoken: string | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    accesstoken?: boolean
    refreshtoken?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    accesstoken?: boolean
    refreshtoken?: boolean
  }


  type UsersGetPayload<S extends boolean | null | undefined | UsersArgs> = $Types.GetResult<UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UsersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Users'> extends True ? Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Users'> extends True ? Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UsersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends UsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersCreateArgs<ExtArgs>>
    ): Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UsersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends UsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>
    ): Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>
    ): Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends UsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>
    ): Prisma__UsersClient<$Types.GetResult<UsersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Users base type for findUnique actions
   */
  export type UsersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUnique
   */
  export interface UsersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UsersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }


  /**
   * Users base type for findFirst actions
   */
  export type UsersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * Users findFirst
   */
  export interface UsersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UsersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UsersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data?: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }


  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UsersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }


  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
  }


  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }


  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }


  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
  }


  /**
   * Users without action
   */
  export type UsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
  }



  /**
   * Model payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    enable: boolean | null
    regionality: string | null
    provider: string | null
    validTill: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    enable: boolean | null
    regionality: string | null
    provider: string | null
    validTill: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    enable: number
    regionality: number
    provider: number
    validTill: number
    _all: number
  }


  export type PaymentMinAggregateInputType = {
    id?: true
    enable?: true
    regionality?: true
    provider?: true
    validTill?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    enable?: true
    regionality?: true
    provider?: true
    validTill?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    enable?: true
    regionality?: true
    provider?: true
    validTill?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithAggregationInput>
    by: PaymentScalarFieldEnum[]
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    enable: boolean | null
    regionality: string | null
    provider: string | null
    validTill: Date | null
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enable?: boolean
    regionality?: boolean
    provider?: boolean
    validTill?: boolean
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectScalar = {
    id?: boolean
    enable?: boolean
    regionality?: boolean
    provider?: boolean
    validTill?: boolean
  }


  type paymentGetPayload<S extends boolean | null | undefined | paymentArgs> = $Types.GetResult<paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<paymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paymentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payment'> extends True ? Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paymentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payment'> extends True ? Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends paymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<paymentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends paymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, paymentCreateArgs<ExtArgs>>
    ): Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends paymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>
    ): Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>
    ): Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends paymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>
    ): Prisma__paymentClient<$Types.GetResult<paymentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * payment base type for findUnique actions
   */
  export type paymentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUnique
   */
  export interface paymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends paymentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment base type for findFirst actions
   */
  export type paymentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * payment findFirst
   */
  export interface paymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends paymentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data?: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }


  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: Enumerable<paymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
  }


  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }


  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
  }


  /**
   * payment without action
   */
  export type paymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
  }



  /**
   * Model logging
   */


  export type AggregateLogging = {
    _count: LoggingCountAggregateOutputType | null
    _min: LoggingMinAggregateOutputType | null
    _max: LoggingMaxAggregateOutputType | null
  }

  export type LoggingMinAggregateOutputType = {
    id: string | null
    corelationId: string | null
    date: string | null
    serviceType: string | null
    logType: string | null
    bookingId: string | null
  }

  export type LoggingMaxAggregateOutputType = {
    id: string | null
    corelationId: string | null
    date: string | null
    serviceType: string | null
    logType: string | null
    bookingId: string | null
  }

  export type LoggingCountAggregateOutputType = {
    id: number
    corelationId: number
    date: number
    serviceType: number
    logType: number
    log: number
    bookingId: number
    _all: number
  }


  export type LoggingMinAggregateInputType = {
    id?: true
    corelationId?: true
    date?: true
    serviceType?: true
    logType?: true
    bookingId?: true
  }

  export type LoggingMaxAggregateInputType = {
    id?: true
    corelationId?: true
    date?: true
    serviceType?: true
    logType?: true
    bookingId?: true
  }

  export type LoggingCountAggregateInputType = {
    id?: true
    corelationId?: true
    date?: true
    serviceType?: true
    logType?: true
    log?: true
    bookingId?: true
    _all?: true
  }

  export type LoggingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which logging to aggregate.
     */
    where?: loggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loggings to fetch.
     */
    orderBy?: Enumerable<loggingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned loggings
    **/
    _count?: true | LoggingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoggingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoggingMaxAggregateInputType
  }

  export type GetLoggingAggregateType<T extends LoggingAggregateArgs> = {
        [P in keyof T & keyof AggregateLogging]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogging[P]>
      : GetScalarType<T[P], AggregateLogging[P]>
  }




  export type LoggingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: loggingWhereInput
    orderBy?: Enumerable<loggingOrderByWithAggregationInput>
    by: LoggingScalarFieldEnum[]
    having?: loggingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoggingCountAggregateInputType | true
    _min?: LoggingMinAggregateInputType
    _max?: LoggingMaxAggregateInputType
  }


  export type LoggingGroupByOutputType = {
    id: string
    corelationId: string | null
    date: string | null
    serviceType: string | null
    logType: string | null
    log: JsonValue | null
    bookingId: string | null
    _count: LoggingCountAggregateOutputType | null
    _min: LoggingMinAggregateOutputType | null
    _max: LoggingMaxAggregateOutputType | null
  }

  type GetLoggingGroupByPayload<T extends LoggingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LoggingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoggingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoggingGroupByOutputType[P]>
            : GetScalarType<T[P], LoggingGroupByOutputType[P]>
        }
      >
    >


  export type loggingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corelationId?: boolean
    date?: boolean
    serviceType?: boolean
    logType?: boolean
    log?: boolean
    bookingId?: boolean
  }, ExtArgs["result"]["logging"]>

  export type loggingSelectScalar = {
    id?: boolean
    corelationId?: boolean
    date?: boolean
    serviceType?: boolean
    logType?: boolean
    log?: boolean
    bookingId?: boolean
  }


  type loggingGetPayload<S extends boolean | null | undefined | loggingArgs> = $Types.GetResult<loggingPayload, S>

  type loggingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<loggingFindManyArgs, 'select' | 'include'> & {
      select?: LoggingCountAggregateInputType | true
    }

  export interface loggingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logging'], meta: { name: 'logging' } }
    /**
     * Find zero or one Logging that matches the filter.
     * @param {loggingFindUniqueArgs} args - Arguments to find a Logging
     * @example
     * // Get one Logging
     * const logging = await prisma.logging.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends loggingFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, loggingFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'logging'> extends True ? Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Logging that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {loggingFindUniqueOrThrowArgs} args - Arguments to find a Logging
     * @example
     * // Get one Logging
     * const logging = await prisma.logging.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends loggingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, loggingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Logging that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loggingFindFirstArgs} args - Arguments to find a Logging
     * @example
     * // Get one Logging
     * const logging = await prisma.logging.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends loggingFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, loggingFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'logging'> extends True ? Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Logging that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loggingFindFirstOrThrowArgs} args - Arguments to find a Logging
     * @example
     * // Get one Logging
     * const logging = await prisma.logging.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends loggingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, loggingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Loggings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loggingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loggings
     * const loggings = await prisma.logging.findMany()
     * 
     * // Get first 10 Loggings
     * const loggings = await prisma.logging.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loggingWithIdOnly = await prisma.logging.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends loggingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, loggingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<loggingPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Logging.
     * @param {loggingCreateArgs} args - Arguments to create a Logging.
     * @example
     * // Create one Logging
     * const Logging = await prisma.logging.create({
     *   data: {
     *     // ... data to create a Logging
     *   }
     * })
     * 
    **/
    create<T extends loggingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, loggingCreateArgs<ExtArgs>>
    ): Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Loggings.
     *     @param {loggingCreateManyArgs} args - Arguments to create many Loggings.
     *     @example
     *     // Create many Loggings
     *     const logging = await prisma.logging.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends loggingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, loggingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logging.
     * @param {loggingDeleteArgs} args - Arguments to delete one Logging.
     * @example
     * // Delete one Logging
     * const Logging = await prisma.logging.delete({
     *   where: {
     *     // ... filter to delete one Logging
     *   }
     * })
     * 
    **/
    delete<T extends loggingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, loggingDeleteArgs<ExtArgs>>
    ): Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Logging.
     * @param {loggingUpdateArgs} args - Arguments to update one Logging.
     * @example
     * // Update one Logging
     * const logging = await prisma.logging.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends loggingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, loggingUpdateArgs<ExtArgs>>
    ): Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Loggings.
     * @param {loggingDeleteManyArgs} args - Arguments to filter Loggings to delete.
     * @example
     * // Delete a few Loggings
     * const { count } = await prisma.logging.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends loggingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, loggingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loggingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loggings
     * const logging = await prisma.logging.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends loggingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, loggingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logging.
     * @param {loggingUpsertArgs} args - Arguments to update or create a Logging.
     * @example
     * // Update or create a Logging
     * const logging = await prisma.logging.upsert({
     *   create: {
     *     // ... data to create a Logging
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logging we want to update
     *   }
     * })
    **/
    upsert<T extends loggingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, loggingUpsertArgs<ExtArgs>>
    ): Prisma__loggingClient<$Types.GetResult<loggingPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Loggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loggingCountArgs} args - Arguments to filter Loggings to count.
     * @example
     * // Count the number of Loggings
     * const count = await prisma.logging.count({
     *   where: {
     *     // ... the filter for the Loggings we want to count
     *   }
     * })
    **/
    count<T extends loggingCountArgs>(
      args?: Subset<T, loggingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoggingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoggingAggregateArgs>(args: Subset<T, LoggingAggregateArgs>): Prisma.PrismaPromise<GetLoggingAggregateType<T>>

    /**
     * Group by Logging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoggingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoggingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoggingGroupByArgs['orderBy'] }
        : { orderBy?: LoggingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoggingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoggingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for logging.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__loggingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * logging base type for findUnique actions
   */
  export type loggingFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * Filter, which logging to fetch.
     */
    where: loggingWhereUniqueInput
  }

  /**
   * logging findUnique
   */
  export interface loggingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends loggingFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * logging findUniqueOrThrow
   */
  export type loggingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * Filter, which logging to fetch.
     */
    where: loggingWhereUniqueInput
  }


  /**
   * logging base type for findFirst actions
   */
  export type loggingFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * Filter, which logging to fetch.
     */
    where?: loggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loggings to fetch.
     */
    orderBy?: Enumerable<loggingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loggings.
     */
    cursor?: loggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loggings.
     */
    distinct?: Enumerable<LoggingScalarFieldEnum>
  }

  /**
   * logging findFirst
   */
  export interface loggingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends loggingFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * logging findFirstOrThrow
   */
  export type loggingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * Filter, which logging to fetch.
     */
    where?: loggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loggings to fetch.
     */
    orderBy?: Enumerable<loggingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loggings.
     */
    cursor?: loggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loggings.
     */
    distinct?: Enumerable<LoggingScalarFieldEnum>
  }


  /**
   * logging findMany
   */
  export type loggingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * Filter, which loggings to fetch.
     */
    where?: loggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loggings to fetch.
     */
    orderBy?: Enumerable<loggingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing loggings.
     */
    cursor?: loggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loggings.
     */
    skip?: number
    distinct?: Enumerable<LoggingScalarFieldEnum>
  }


  /**
   * logging create
   */
  export type loggingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * The data needed to create a logging.
     */
    data?: XOR<loggingCreateInput, loggingUncheckedCreateInput>
  }


  /**
   * logging createMany
   */
  export type loggingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many loggings.
     */
    data: Enumerable<loggingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * logging update
   */
  export type loggingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * The data needed to update a logging.
     */
    data: XOR<loggingUpdateInput, loggingUncheckedUpdateInput>
    /**
     * Choose, which logging to update.
     */
    where: loggingWhereUniqueInput
  }


  /**
   * logging updateMany
   */
  export type loggingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update loggings.
     */
    data: XOR<loggingUpdateManyMutationInput, loggingUncheckedUpdateManyInput>
    /**
     * Filter which loggings to update
     */
    where?: loggingWhereInput
  }


  /**
   * logging upsert
   */
  export type loggingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * The filter to search for the logging to update in case it exists.
     */
    where: loggingWhereUniqueInput
    /**
     * In case the logging found by the `where` argument doesn't exist, create a new logging with this data.
     */
    create: XOR<loggingCreateInput, loggingUncheckedCreateInput>
    /**
     * In case the logging was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loggingUpdateInput, loggingUncheckedUpdateInput>
  }


  /**
   * logging delete
   */
  export type loggingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
    /**
     * Filter which logging to delete.
     */
    where: loggingWhereUniqueInput
  }


  /**
   * logging deleteMany
   */
  export type loggingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which loggings to delete
     */
    where?: loggingWhereInput
  }


  /**
   * logging without action
   */
  export type loggingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logging
     */
    select?: loggingSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SpecialServiceRuleTableScalarFieldEnum: {
    id: 'id',
    enable: 'enable',
    currency: 'currency',
    origin: 'origin',
    destination: 'destination',
    carriercode: 'carriercode',
    offermeals: 'offermeals',
    offerseats: 'offerseats',
    Offerfrequentflyermiles: 'Offerfrequentflyermiles',
    offerpricewithincludedbaggage: 'offerpricewithincludedbaggage'
  };

  export type SpecialServiceRuleTableScalarFieldEnum = (typeof SpecialServiceRuleTableScalarFieldEnum)[keyof typeof SpecialServiceRuleTableScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    iata: 'iata',
    cityName: 'cityName',
    airportName: 'airportName',
    country: 'country',
    countryCode: 'countryCode',
    icon: 'icon'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    orderRef: 'orderRef',
    orderType: 'orderType',
    status: 'status',
    reference: 'reference',
    paymentIntentId: 'paymentIntentId',
    paymentStatus: 'paymentStatus',
    supplier: 'supplier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    stripeSessionId: 'stripeSessionId',
    razorpayOrderId: 'razorpayOrderId',
    flightOfferId: 'flightOfferId',
    flightInternalSource: 'flightInternalSource',
    userEmail: 'userEmail'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PassengerScalarFieldEnum: {
    id: 'id',
    passengerId: 'passengerId',
    countryCode: 'countryCode',
    email: 'email',
    dateOfBirth: 'dateOfBirth',
    passengerType: 'passengerType',
    title: 'title',
    gender: 'gender',
    firstName: 'firstName',
    lastName: 'lastName',
    seatNumber: 'seatNumber',
    fareOption: 'fareOption',
    bookingId: 'bookingId',
    phone: 'phone'
  };

  export type PassengerScalarFieldEnum = (typeof PassengerScalarFieldEnum)[keyof typeof PassengerScalarFieldEnum]


  export const ItineraryScalarFieldEnum: {
    id: 'id',
    duration: 'duration',
    bookingId: 'bookingId'
  };

  export type ItineraryScalarFieldEnum = (typeof ItineraryScalarFieldEnum)[keyof typeof ItineraryScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    number: 'number',
    issuanceDate: 'issuanceDate',
    expiryDate: 'expiryDate',
    issuanceCountryCode: 'issuanceCountryCode',
    issuanceLocation: 'issuanceLocation',
    nationality: 'nationality',
    documentType: 'documentType',
    passengerId: 'passengerId',
    holder: 'holder',
    birthPlace: 'birthPlace'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const PriceScalarFieldEnum: {
    id: 'id',
    basePrice: 'basePrice',
    grandTotal: 'grandTotal',
    discountAmt: 'discountAmt',
    commissionAmt: 'commissionAmt',
    currency: 'currency',
    bookingId: 'bookingId'
  };

  export type PriceScalarFieldEnum = (typeof PriceScalarFieldEnum)[keyof typeof PriceScalarFieldEnum]


  export const FeeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    refundable: 'refundable',
    currency: 'currency',
    priceId: 'priceId'
  };

  export type FeeScalarFieldEnum = (typeof FeeScalarFieldEnum)[keyof typeof FeeScalarFieldEnum]


  export const BaggageScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    weight: 'weight',
    type: 'type',
    passengerId: 'passengerId'
  };

  export type BaggageScalarFieldEnum = (typeof BaggageScalarFieldEnum)[keyof typeof BaggageScalarFieldEnum]


  export const RouteScalarFieldEnum: {
    id: 'id',
    departIataCode: 'departIataCode',
    departTerminal: 'departTerminal',
    departAt: 'departAt',
    arrivalIataCode: 'arrivalIataCode',
    arrivalTerminal: 'arrivalTerminal',
    arrivalAt: 'arrivalAt',
    flightNumber: 'flightNumber',
    aircraftCode: 'aircraftCode',
    duration: 'duration',
    numberOfStops: 'numberOfStops',
    carrierCode: 'carrierCode',
    routeId: 'routeId',
    itineraryId: 'itineraryId'
  };

  export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


  export const FareDetailsByRouteScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    fareBasis: 'fareBasis',
    class: 'class',
    brandedFare: 'brandedFare',
    includedCheckedBagsUnit: 'includedCheckedBagsUnit',
    includedCheckedBagsWeight: 'includedCheckedBagsWeight',
    includedCheckedBagsWeightUnit: 'includedCheckedBagsWeightUnit',
    cabin: 'cabin',
    passengerId: 'passengerId'
  };

  export type FareDetailsByRouteScalarFieldEnum = (typeof FareDetailsByRouteScalarFieldEnum)[keyof typeof FareDetailsByRouteScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    accesstoken: 'accesstoken',
    refreshtoken: 'refreshtoken'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    enable: 'enable',
    regionality: 'regionality',
    provider: 'provider',
    validTill: 'validTill'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const LoggingScalarFieldEnum: {
    id: 'id',
    corelationId: 'corelationId',
    date: 'date',
    serviceType: 'serviceType',
    logType: 'logType',
    log: 'log',
    bookingId: 'bookingId'
  };

  export type LoggingScalarFieldEnum = (typeof LoggingScalarFieldEnum)[keyof typeof LoggingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type specialServiceRuleTableWhereInput = {
    AND?: Enumerable<specialServiceRuleTableWhereInput>
    OR?: Enumerable<specialServiceRuleTableWhereInput>
    NOT?: Enumerable<specialServiceRuleTableWhereInput>
    id?: StringFilter | string
    enable?: BoolNullableFilter | boolean | null
    currency?: StringNullableFilter | string | null
    origin?: StringNullableFilter | string | null
    destination?: StringNullableFilter | string | null
    carriercode?: StringNullableFilter | string | null
    offermeals?: BoolNullableFilter | boolean | null
    offerseats?: BoolNullableFilter | boolean | null
    Offerfrequentflyermiles?: BoolNullableFilter | boolean | null
    offerpricewithincludedbaggage?: BoolNullableFilter | boolean | null
  }

  export type specialServiceRuleTableOrderByWithRelationInput = {
    id?: SortOrder
    enable?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    carriercode?: SortOrderInput | SortOrder
    offermeals?: SortOrderInput | SortOrder
    offerseats?: SortOrderInput | SortOrder
    Offerfrequentflyermiles?: SortOrderInput | SortOrder
    offerpricewithincludedbaggage?: SortOrderInput | SortOrder
  }

  export type specialServiceRuleTableWhereUniqueInput = {
    id?: string
  }

  export type specialServiceRuleTableOrderByWithAggregationInput = {
    id?: SortOrder
    enable?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    carriercode?: SortOrderInput | SortOrder
    offermeals?: SortOrderInput | SortOrder
    offerseats?: SortOrderInput | SortOrder
    Offerfrequentflyermiles?: SortOrderInput | SortOrder
    offerpricewithincludedbaggage?: SortOrderInput | SortOrder
    _count?: specialServiceRuleTableCountOrderByAggregateInput
    _max?: specialServiceRuleTableMaxOrderByAggregateInput
    _min?: specialServiceRuleTableMinOrderByAggregateInput
  }

  export type specialServiceRuleTableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<specialServiceRuleTableScalarWhereWithAggregatesInput>
    OR?: Enumerable<specialServiceRuleTableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<specialServiceRuleTableScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    enable?: BoolNullableWithAggregatesFilter | boolean | null
    currency?: StringNullableWithAggregatesFilter | string | null
    origin?: StringNullableWithAggregatesFilter | string | null
    destination?: StringNullableWithAggregatesFilter | string | null
    carriercode?: StringNullableWithAggregatesFilter | string | null
    offermeals?: BoolNullableWithAggregatesFilter | boolean | null
    offerseats?: BoolNullableWithAggregatesFilter | boolean | null
    Offerfrequentflyermiles?: BoolNullableWithAggregatesFilter | boolean | null
    offerpricewithincludedbaggage?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type locationsWhereInput = {
    AND?: Enumerable<locationsWhereInput>
    OR?: Enumerable<locationsWhereInput>
    NOT?: Enumerable<locationsWhereInput>
    id?: StringFilter | string
    iata?: StringNullableFilter | string | null
    cityName?: StringNullableFilter | string | null
    airportName?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    countryCode?: StringNullableFilter | string | null
    icon?: StringNullableFilter | string | null
  }

  export type locationsOrderByWithRelationInput = {
    id?: SortOrder
    iata?: SortOrderInput | SortOrder
    cityName?: SortOrderInput | SortOrder
    airportName?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
  }

  export type locationsWhereUniqueInput = {
    id?: string
  }

  export type locationsOrderByWithAggregationInput = {
    id?: SortOrder
    iata?: SortOrderInput | SortOrder
    cityName?: SortOrderInput | SortOrder
    airportName?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: locationsCountOrderByAggregateInput
    _max?: locationsMaxOrderByAggregateInput
    _min?: locationsMinOrderByAggregateInput
  }

  export type locationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<locationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<locationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<locationsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    iata?: StringNullableWithAggregatesFilter | string | null
    cityName?: StringNullableWithAggregatesFilter | string | null
    airportName?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    countryCode?: StringNullableWithAggregatesFilter | string | null
    icon?: StringNullableWithAggregatesFilter | string | null
  }

  export type BookingWhereInput = {
    AND?: Enumerable<BookingWhereInput>
    OR?: Enumerable<BookingWhereInput>
    NOT?: Enumerable<BookingWhereInput>
    id?: StringFilter | string
    orderId?: StringNullableFilter | string | null
    orderRef?: StringNullableFilter | string | null
    orderType?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    reference?: StringNullableFilter | string | null
    paymentIntentId?: StringNullableFilter | string | null
    paymentStatus?: StringNullableFilter | string | null
    supplier?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    stripeSessionId?: StringNullableFilter | string | null
    razorpayOrderId?: StringNullableFilter | string | null
    flightOfferId?: StringNullableFilter | string | null
    flightInternalSource?: StringNullableFilter | string | null
    userEmail?: StringNullableFilter | string | null
    Passenger?: PassengerListRelationFilter
    Itinerary?: ItineraryListRelationFilter
    Price?: PriceListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderRef?: SortOrderInput | SortOrder
    orderType?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    stripeSessionId?: SortOrderInput | SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    flightOfferId?: SortOrderInput | SortOrder
    flightInternalSource?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    Passenger?: PassengerOrderByRelationAggregateInput
    Itinerary?: ItineraryOrderByRelationAggregateInput
    Price?: PriceOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = {
    id?: string
  }

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    orderRef?: SortOrderInput | SortOrder
    orderType?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    stripeSessionId?: SortOrderInput | SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    flightOfferId?: SortOrderInput | SortOrder
    flightInternalSource?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookingScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    orderId?: StringNullableWithAggregatesFilter | string | null
    orderRef?: StringNullableWithAggregatesFilter | string | null
    orderType?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    reference?: StringNullableWithAggregatesFilter | string | null
    paymentIntentId?: StringNullableWithAggregatesFilter | string | null
    paymentStatus?: StringNullableWithAggregatesFilter | string | null
    supplier?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stripeSessionId?: StringNullableWithAggregatesFilter | string | null
    razorpayOrderId?: StringNullableWithAggregatesFilter | string | null
    flightOfferId?: StringNullableWithAggregatesFilter | string | null
    flightInternalSource?: StringNullableWithAggregatesFilter | string | null
    userEmail?: StringNullableWithAggregatesFilter | string | null
  }

  export type PassengerWhereInput = {
    AND?: Enumerable<PassengerWhereInput>
    OR?: Enumerable<PassengerWhereInput>
    NOT?: Enumerable<PassengerWhereInput>
    id?: StringFilter | string
    passengerId?: StringNullableFilter | string | null
    countryCode?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    dateOfBirth?: StringNullableFilter | string | null
    passengerType?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    gender?: StringNullableFilter | string | null
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    seatNumber?: StringNullableFilter | string | null
    fareOption?: StringNullableFilter | string | null
    bookingId?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    Booking?: XOR<BookingRelationFilter, BookingWhereInput> | null
    Document?: DocumentListRelationFilter
    Baggage?: BaggageListRelationFilter
    fareDetailsByRoute?: FareDetailsByRouteListRelationFilter
  }

  export type PassengerOrderByWithRelationInput = {
    id?: SortOrder
    passengerId?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    passengerType?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    seatNumber?: SortOrderInput | SortOrder
    fareOption?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    Booking?: BookingOrderByWithRelationInput
    Document?: DocumentOrderByRelationAggregateInput
    Baggage?: BaggageOrderByRelationAggregateInput
    fareDetailsByRoute?: fareDetailsByRouteOrderByRelationAggregateInput
  }

  export type PassengerWhereUniqueInput = {
    id?: string
  }

  export type PassengerOrderByWithAggregationInput = {
    id?: SortOrder
    passengerId?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    passengerType?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    seatNumber?: SortOrderInput | SortOrder
    fareOption?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: PassengerCountOrderByAggregateInput
    _max?: PassengerMaxOrderByAggregateInput
    _min?: PassengerMinOrderByAggregateInput
  }

  export type PassengerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PassengerScalarWhereWithAggregatesInput>
    OR?: Enumerable<PassengerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PassengerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    passengerId?: StringNullableWithAggregatesFilter | string | null
    countryCode?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    dateOfBirth?: StringNullableWithAggregatesFilter | string | null
    passengerType?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    gender?: StringNullableWithAggregatesFilter | string | null
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    seatNumber?: StringNullableWithAggregatesFilter | string | null
    fareOption?: StringNullableWithAggregatesFilter | string | null
    bookingId?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
  }

  export type ItineraryWhereInput = {
    AND?: Enumerable<ItineraryWhereInput>
    OR?: Enumerable<ItineraryWhereInput>
    NOT?: Enumerable<ItineraryWhereInput>
    id?: StringFilter | string
    duration?: StringNullableFilter | string | null
    bookingId?: StringNullableFilter | string | null
    Booking?: XOR<BookingRelationFilter, BookingWhereInput> | null
    Route?: RouteListRelationFilter
  }

  export type ItineraryOrderByWithRelationInput = {
    id?: SortOrder
    duration?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    Booking?: BookingOrderByWithRelationInput
    Route?: RouteOrderByRelationAggregateInput
  }

  export type ItineraryWhereUniqueInput = {
    id?: string
  }

  export type ItineraryOrderByWithAggregationInput = {
    id?: SortOrder
    duration?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    _count?: ItineraryCountOrderByAggregateInput
    _max?: ItineraryMaxOrderByAggregateInput
    _min?: ItineraryMinOrderByAggregateInput
  }

  export type ItineraryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItineraryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItineraryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItineraryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    duration?: StringNullableWithAggregatesFilter | string | null
    bookingId?: StringNullableWithAggregatesFilter | string | null
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    number?: StringNullableFilter | string | null
    issuanceDate?: StringNullableFilter | string | null
    expiryDate?: StringNullableFilter | string | null
    issuanceCountryCode?: StringNullableFilter | string | null
    issuanceLocation?: StringNullableFilter | string | null
    nationality?: StringNullableFilter | string | null
    documentType?: StringNullableFilter | string | null
    passengerId?: StringNullableFilter | string | null
    holder?: BoolNullableFilter | boolean | null
    birthPlace?: StringNullableFilter | string | null
    Passenger?: XOR<PassengerRelationFilter, PassengerWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrderInput | SortOrder
    issuanceDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    issuanceCountryCode?: SortOrderInput | SortOrder
    issuanceLocation?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    passengerId?: SortOrderInput | SortOrder
    holder?: SortOrderInput | SortOrder
    birthPlace?: SortOrderInput | SortOrder
    Passenger?: PassengerOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrderInput | SortOrder
    issuanceDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    issuanceCountryCode?: SortOrderInput | SortOrder
    issuanceLocation?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    passengerId?: SortOrderInput | SortOrder
    holder?: SortOrderInput | SortOrder
    birthPlace?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    number?: StringNullableWithAggregatesFilter | string | null
    issuanceDate?: StringNullableWithAggregatesFilter | string | null
    expiryDate?: StringNullableWithAggregatesFilter | string | null
    issuanceCountryCode?: StringNullableWithAggregatesFilter | string | null
    issuanceLocation?: StringNullableWithAggregatesFilter | string | null
    nationality?: StringNullableWithAggregatesFilter | string | null
    documentType?: StringNullableWithAggregatesFilter | string | null
    passengerId?: StringNullableWithAggregatesFilter | string | null
    holder?: BoolNullableWithAggregatesFilter | boolean | null
    birthPlace?: StringNullableWithAggregatesFilter | string | null
  }

  export type PriceWhereInput = {
    AND?: Enumerable<PriceWhereInput>
    OR?: Enumerable<PriceWhereInput>
    NOT?: Enumerable<PriceWhereInput>
    id?: StringFilter | string
    basePrice?: StringNullableFilter | string | null
    grandTotal?: StringNullableFilter | string | null
    discountAmt?: StringNullableFilter | string | null
    commissionAmt?: StringNullableFilter | string | null
    currency?: StringNullableFilter | string | null
    bookingId?: StringNullableFilter | string | null
    Booking?: XOR<BookingRelationFilter, BookingWhereInput> | null
    Fee?: FeeListRelationFilter
  }

  export type PriceOrderByWithRelationInput = {
    id?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    grandTotal?: SortOrderInput | SortOrder
    discountAmt?: SortOrderInput | SortOrder
    commissionAmt?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    Booking?: BookingOrderByWithRelationInput
    Fee?: FeeOrderByRelationAggregateInput
  }

  export type PriceWhereUniqueInput = {
    id?: string
  }

  export type PriceOrderByWithAggregationInput = {
    id?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    grandTotal?: SortOrderInput | SortOrder
    discountAmt?: SortOrderInput | SortOrder
    commissionAmt?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    _count?: PriceCountOrderByAggregateInput
    _max?: PriceMaxOrderByAggregateInput
    _min?: PriceMinOrderByAggregateInput
  }

  export type PriceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PriceScalarWhereWithAggregatesInput>
    OR?: Enumerable<PriceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PriceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    basePrice?: StringNullableWithAggregatesFilter | string | null
    grandTotal?: StringNullableWithAggregatesFilter | string | null
    discountAmt?: StringNullableWithAggregatesFilter | string | null
    commissionAmt?: StringNullableWithAggregatesFilter | string | null
    currency?: StringNullableWithAggregatesFilter | string | null
    bookingId?: StringNullableWithAggregatesFilter | string | null
  }

  export type FeeWhereInput = {
    AND?: Enumerable<FeeWhereInput>
    OR?: Enumerable<FeeWhereInput>
    NOT?: Enumerable<FeeWhereInput>
    id?: StringFilter | string
    type?: StringNullableFilter | string | null
    amount?: StringNullableFilter | string | null
    refundable?: StringNullableFilter | string | null
    currency?: StringNullableFilter | string | null
    priceId?: StringNullableFilter | string | null
    Price?: XOR<PriceRelationFilter, PriceWhereInput> | null
  }

  export type FeeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    refundable?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    Price?: PriceOrderByWithRelationInput
  }

  export type FeeWhereUniqueInput = {
    id?: string
  }

  export type FeeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    refundable?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    _count?: FeeCountOrderByAggregateInput
    _max?: FeeMaxOrderByAggregateInput
    _min?: FeeMinOrderByAggregateInput
  }

  export type FeeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeeScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
    amount?: StringNullableWithAggregatesFilter | string | null
    refundable?: StringNullableWithAggregatesFilter | string | null
    currency?: StringNullableWithAggregatesFilter | string | null
    priceId?: StringNullableWithAggregatesFilter | string | null
  }

  export type BaggageWhereInput = {
    AND?: Enumerable<BaggageWhereInput>
    OR?: Enumerable<BaggageWhereInput>
    NOT?: Enumerable<BaggageWhereInput>
    id?: StringFilter | string
    quantity?: IntNullableFilter | number | null
    weight?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    passengerId?: StringNullableFilter | string | null
    Passenger?: XOR<PassengerRelationFilter, PassengerWhereInput> | null
  }

  export type BaggageOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    passengerId?: SortOrderInput | SortOrder
    Passenger?: PassengerOrderByWithRelationInput
  }

  export type BaggageWhereUniqueInput = {
    id?: string
  }

  export type BaggageOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    passengerId?: SortOrderInput | SortOrder
    _count?: BaggageCountOrderByAggregateInput
    _avg?: BaggageAvgOrderByAggregateInput
    _max?: BaggageMaxOrderByAggregateInput
    _min?: BaggageMinOrderByAggregateInput
    _sum?: BaggageSumOrderByAggregateInput
  }

  export type BaggageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BaggageScalarWhereWithAggregatesInput>
    OR?: Enumerable<BaggageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BaggageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    quantity?: IntNullableWithAggregatesFilter | number | null
    weight?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    passengerId?: StringNullableWithAggregatesFilter | string | null
  }

  export type RouteWhereInput = {
    AND?: Enumerable<RouteWhereInput>
    OR?: Enumerable<RouteWhereInput>
    NOT?: Enumerable<RouteWhereInput>
    id?: StringFilter | string
    departIataCode?: StringNullableFilter | string | null
    departTerminal?: StringNullableFilter | string | null
    departAt?: StringNullableFilter | string | null
    arrivalIataCode?: StringNullableFilter | string | null
    arrivalTerminal?: StringNullableFilter | string | null
    arrivalAt?: StringNullableFilter | string | null
    flightNumber?: StringNullableFilter | string | null
    aircraftCode?: StringNullableFilter | string | null
    duration?: StringNullableFilter | string | null
    numberOfStops?: IntNullableFilter | number | null
    carrierCode?: StringNullableFilter | string | null
    routeId?: StringNullableFilter | string | null
    itineraryId?: StringNullableFilter | string | null
    Itinerary?: XOR<ItineraryRelationFilter, ItineraryWhereInput> | null
  }

  export type RouteOrderByWithRelationInput = {
    id?: SortOrder
    departIataCode?: SortOrderInput | SortOrder
    departTerminal?: SortOrderInput | SortOrder
    departAt?: SortOrderInput | SortOrder
    arrivalIataCode?: SortOrderInput | SortOrder
    arrivalTerminal?: SortOrderInput | SortOrder
    arrivalAt?: SortOrderInput | SortOrder
    flightNumber?: SortOrderInput | SortOrder
    aircraftCode?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    numberOfStops?: SortOrderInput | SortOrder
    carrierCode?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    itineraryId?: SortOrderInput | SortOrder
    Itinerary?: ItineraryOrderByWithRelationInput
  }

  export type RouteWhereUniqueInput = {
    id?: string
  }

  export type RouteOrderByWithAggregationInput = {
    id?: SortOrder
    departIataCode?: SortOrderInput | SortOrder
    departTerminal?: SortOrderInput | SortOrder
    departAt?: SortOrderInput | SortOrder
    arrivalIataCode?: SortOrderInput | SortOrder
    arrivalTerminal?: SortOrderInput | SortOrder
    arrivalAt?: SortOrderInput | SortOrder
    flightNumber?: SortOrderInput | SortOrder
    aircraftCode?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    numberOfStops?: SortOrderInput | SortOrder
    carrierCode?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    itineraryId?: SortOrderInput | SortOrder
    _count?: RouteCountOrderByAggregateInput
    _avg?: RouteAvgOrderByAggregateInput
    _max?: RouteMaxOrderByAggregateInput
    _min?: RouteMinOrderByAggregateInput
    _sum?: RouteSumOrderByAggregateInput
  }

  export type RouteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RouteScalarWhereWithAggregatesInput>
    OR?: Enumerable<RouteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RouteScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    departIataCode?: StringNullableWithAggregatesFilter | string | null
    departTerminal?: StringNullableWithAggregatesFilter | string | null
    departAt?: StringNullableWithAggregatesFilter | string | null
    arrivalIataCode?: StringNullableWithAggregatesFilter | string | null
    arrivalTerminal?: StringNullableWithAggregatesFilter | string | null
    arrivalAt?: StringNullableWithAggregatesFilter | string | null
    flightNumber?: StringNullableWithAggregatesFilter | string | null
    aircraftCode?: StringNullableWithAggregatesFilter | string | null
    duration?: StringNullableWithAggregatesFilter | string | null
    numberOfStops?: IntNullableWithAggregatesFilter | number | null
    carrierCode?: StringNullableWithAggregatesFilter | string | null
    routeId?: StringNullableWithAggregatesFilter | string | null
    itineraryId?: StringNullableWithAggregatesFilter | string | null
  }

  export type fareDetailsByRouteWhereInput = {
    AND?: Enumerable<fareDetailsByRouteWhereInput>
    OR?: Enumerable<fareDetailsByRouteWhereInput>
    NOT?: Enumerable<fareDetailsByRouteWhereInput>
    id?: StringFilter | string
    routeId?: StringNullableFilter | string | null
    fareBasis?: StringNullableFilter | string | null
    class?: StringNullableFilter | string | null
    brandedFare?: StringNullableFilter | string | null
    includedCheckedBagsUnit?: IntNullableFilter | number | null
    includedCheckedBagsWeight?: IntNullableFilter | number | null
    includedCheckedBagsWeightUnit?: StringNullableFilter | string | null
    cabin?: StringNullableFilter | string | null
    passengerId?: StringNullableFilter | string | null
    Passenger?: XOR<PassengerRelationFilter, PassengerWhereInput> | null
  }

  export type fareDetailsByRouteOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrderInput | SortOrder
    fareBasis?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    brandedFare?: SortOrderInput | SortOrder
    includedCheckedBagsUnit?: SortOrderInput | SortOrder
    includedCheckedBagsWeight?: SortOrderInput | SortOrder
    includedCheckedBagsWeightUnit?: SortOrderInput | SortOrder
    cabin?: SortOrderInput | SortOrder
    passengerId?: SortOrderInput | SortOrder
    Passenger?: PassengerOrderByWithRelationInput
  }

  export type fareDetailsByRouteWhereUniqueInput = {
    id?: string
  }

  export type fareDetailsByRouteOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrderInput | SortOrder
    fareBasis?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    brandedFare?: SortOrderInput | SortOrder
    includedCheckedBagsUnit?: SortOrderInput | SortOrder
    includedCheckedBagsWeight?: SortOrderInput | SortOrder
    includedCheckedBagsWeightUnit?: SortOrderInput | SortOrder
    cabin?: SortOrderInput | SortOrder
    passengerId?: SortOrderInput | SortOrder
    _count?: fareDetailsByRouteCountOrderByAggregateInput
    _avg?: fareDetailsByRouteAvgOrderByAggregateInput
    _max?: fareDetailsByRouteMaxOrderByAggregateInput
    _min?: fareDetailsByRouteMinOrderByAggregateInput
    _sum?: fareDetailsByRouteSumOrderByAggregateInput
  }

  export type fareDetailsByRouteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fareDetailsByRouteScalarWhereWithAggregatesInput>
    OR?: Enumerable<fareDetailsByRouteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fareDetailsByRouteScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    routeId?: StringNullableWithAggregatesFilter | string | null
    fareBasis?: StringNullableWithAggregatesFilter | string | null
    class?: StringNullableWithAggregatesFilter | string | null
    brandedFare?: StringNullableWithAggregatesFilter | string | null
    includedCheckedBagsUnit?: IntNullableWithAggregatesFilter | number | null
    includedCheckedBagsWeight?: IntNullableWithAggregatesFilter | number | null
    includedCheckedBagsWeightUnit?: StringNullableWithAggregatesFilter | string | null
    cabin?: StringNullableWithAggregatesFilter | string | null
    passengerId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UsersWhereInput = {
    AND?: Enumerable<UsersWhereInput>
    OR?: Enumerable<UsersWhereInput>
    NOT?: Enumerable<UsersWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    accesstoken?: StringNullableFilter | string | null
    refreshtoken?: StringNullableFilter | string | null
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    accesstoken?: SortOrderInput | SortOrder
    refreshtoken?: SortOrderInput | SortOrder
  }

  export type UsersWhereUniqueInput = {
    id?: string
  }

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    accesstoken?: SortOrderInput | SortOrder
    refreshtoken?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsersScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    accesstoken?: StringNullableWithAggregatesFilter | string | null
    refreshtoken?: StringNullableWithAggregatesFilter | string | null
  }

  export type paymentWhereInput = {
    AND?: Enumerable<paymentWhereInput>
    OR?: Enumerable<paymentWhereInput>
    NOT?: Enumerable<paymentWhereInput>
    id?: StringFilter | string
    enable?: BoolNullableFilter | boolean | null
    regionality?: StringNullableFilter | string | null
    provider?: StringNullableFilter | string | null
    validTill?: DateTimeNullableFilter | Date | string | null
  }

  export type paymentOrderByWithRelationInput = {
    id?: SortOrder
    enable?: SortOrderInput | SortOrder
    regionality?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    validTill?: SortOrderInput | SortOrder
  }

  export type paymentWhereUniqueInput = {
    id?: string
  }

  export type paymentOrderByWithAggregationInput = {
    id?: SortOrder
    enable?: SortOrderInput | SortOrder
    regionality?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    validTill?: SortOrderInput | SortOrder
    _count?: paymentCountOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<paymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    enable?: BoolNullableWithAggregatesFilter | boolean | null
    regionality?: StringNullableWithAggregatesFilter | string | null
    provider?: StringNullableWithAggregatesFilter | string | null
    validTill?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type loggingWhereInput = {
    AND?: Enumerable<loggingWhereInput>
    OR?: Enumerable<loggingWhereInput>
    NOT?: Enumerable<loggingWhereInput>
    id?: StringFilter | string
    corelationId?: StringNullableFilter | string | null
    date?: StringNullableFilter | string | null
    serviceType?: StringNullableFilter | string | null
    logType?: StringNullableFilter | string | null
    log?: JsonNullableFilter
    bookingId?: StringNullableFilter | string | null
  }

  export type loggingOrderByWithRelationInput = {
    id?: SortOrder
    corelationId?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    logType?: SortOrderInput | SortOrder
    log?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
  }

  export type loggingWhereUniqueInput = {
    id?: string
  }

  export type loggingOrderByWithAggregationInput = {
    id?: SortOrder
    corelationId?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    logType?: SortOrderInput | SortOrder
    log?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    _count?: loggingCountOrderByAggregateInput
    _max?: loggingMaxOrderByAggregateInput
    _min?: loggingMinOrderByAggregateInput
  }

  export type loggingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<loggingScalarWhereWithAggregatesInput>
    OR?: Enumerable<loggingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<loggingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    corelationId?: StringNullableWithAggregatesFilter | string | null
    date?: StringNullableWithAggregatesFilter | string | null
    serviceType?: StringNullableWithAggregatesFilter | string | null
    logType?: StringNullableWithAggregatesFilter | string | null
    log?: JsonNullableWithAggregatesFilter
    bookingId?: StringNullableWithAggregatesFilter | string | null
  }

  export type specialServiceRuleTableCreateInput = {
    id?: string
    enable?: boolean | null
    currency?: string | null
    origin?: string | null
    destination?: string | null
    carriercode?: string | null
    offermeals?: boolean | null
    offerseats?: boolean | null
    Offerfrequentflyermiles?: boolean | null
    offerpricewithincludedbaggage?: boolean | null
  }

  export type specialServiceRuleTableUncheckedCreateInput = {
    id?: string
    enable?: boolean | null
    currency?: string | null
    origin?: string | null
    destination?: string | null
    carriercode?: string | null
    offermeals?: boolean | null
    offerseats?: boolean | null
    Offerfrequentflyermiles?: boolean | null
    offerpricewithincludedbaggage?: boolean | null
  }

  export type specialServiceRuleTableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    carriercode?: NullableStringFieldUpdateOperationsInput | string | null
    offermeals?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerseats?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Offerfrequentflyermiles?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerpricewithincludedbaggage?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type specialServiceRuleTableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    carriercode?: NullableStringFieldUpdateOperationsInput | string | null
    offermeals?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerseats?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Offerfrequentflyermiles?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerpricewithincludedbaggage?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type specialServiceRuleTableCreateManyInput = {
    id?: string
    enable?: boolean | null
    currency?: string | null
    origin?: string | null
    destination?: string | null
    carriercode?: string | null
    offermeals?: boolean | null
    offerseats?: boolean | null
    Offerfrequentflyermiles?: boolean | null
    offerpricewithincludedbaggage?: boolean | null
  }

  export type specialServiceRuleTableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    carriercode?: NullableStringFieldUpdateOperationsInput | string | null
    offermeals?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerseats?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Offerfrequentflyermiles?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerpricewithincludedbaggage?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type specialServiceRuleTableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    carriercode?: NullableStringFieldUpdateOperationsInput | string | null
    offermeals?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerseats?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Offerfrequentflyermiles?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offerpricewithincludedbaggage?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type locationsCreateInput = {
    id?: string
    iata?: string | null
    cityName?: string | null
    airportName?: string | null
    country?: string | null
    countryCode?: string | null
    icon?: string | null
  }

  export type locationsUncheckedCreateInput = {
    id?: string
    iata?: string | null
    cityName?: string | null
    airportName?: string | null
    country?: string | null
    countryCode?: string | null
    icon?: string | null
  }

  export type locationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    airportName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    airportName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationsCreateManyInput = {
    id?: string
    iata?: string | null
    cityName?: string | null
    airportName?: string | null
    country?: string | null
    countryCode?: string | null
    icon?: string | null
  }

  export type locationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    airportName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    iata?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    airportName?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Passenger?: PassengerCreateNestedManyWithoutBookingInput
    Itinerary?: ItineraryCreateNestedManyWithoutBookingInput
    Price?: PriceCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Passenger?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    Itinerary?: ItineraryUncheckedCreateNestedManyWithoutBookingInput
    Price?: PriceUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUpdateManyWithoutBookingNestedInput
    Itinerary?: ItineraryUpdateManyWithoutBookingNestedInput
    Price?: PriceUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    Itinerary?: ItineraryUncheckedUpdateManyWithoutBookingNestedInput
    Price?: PriceUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerCreateInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    phone?: string | null
    Booking?: BookingCreateNestedOneWithoutPassengerInput
    Document?: DocumentCreateNestedManyWithoutPassengerInput
    Baggage?: BaggageCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteCreateNestedManyWithoutPassengerInput
  }

  export type PassengerUncheckedCreateInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    bookingId?: string | null
    phone?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutPassengerInput
    Baggage?: BaggageUncheckedCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type PassengerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutPassengerNestedInput
    Document?: DocumentUpdateManyWithoutPassengerNestedInput
    Baggage?: BaggageUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutPassengerNestedInput
    Baggage?: BaggageUncheckedUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerCreateManyInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    bookingId?: string | null
    phone?: string | null
  }

  export type PassengerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryCreateInput = {
    id?: string
    duration?: string | null
    Booking?: BookingCreateNestedOneWithoutItineraryInput
    Route?: RouteCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateInput = {
    id?: string
    duration?: string | null
    bookingId?: string | null
    Route?: RouteUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutItineraryNestedInput
    Route?: RouteUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    Route?: RouteUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryCreateManyInput = {
    id?: string
    duration?: string | null
    bookingId?: string | null
  }

  export type ItineraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    number?: string | null
    issuanceDate?: string | null
    expiryDate?: string | null
    issuanceCountryCode?: string | null
    issuanceLocation?: string | null
    nationality?: string | null
    documentType?: string | null
    holder?: boolean | null
    birthPlace?: string | null
    Passenger?: PassengerCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    number?: string | null
    issuanceDate?: string | null
    expiryDate?: string | null
    issuanceCountryCode?: string | null
    issuanceLocation?: string | null
    nationality?: string | null
    documentType?: string | null
    passengerId?: string | null
    holder?: boolean | null
    birthPlace?: string | null
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceDate?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceLocation?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceDate?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceLocation?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyInput = {
    id?: string
    number?: string | null
    issuanceDate?: string | null
    expiryDate?: string | null
    issuanceCountryCode?: string | null
    issuanceLocation?: string | null
    nationality?: string | null
    documentType?: string | null
    passengerId?: string | null
    holder?: boolean | null
    birthPlace?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceDate?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceLocation?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceDate?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceLocation?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceCreateInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
    Booking?: BookingCreateNestedOneWithoutPriceInput
    Fee?: FeeCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
    bookingId?: string | null
    Fee?: FeeUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutPriceNestedInput
    Fee?: FeeUpdateManyWithoutPriceNestedInput
  }

  export type PriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    Fee?: FeeUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PriceCreateManyInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
    bookingId?: string | null
  }

  export type PriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeCreateInput = {
    id?: string
    type?: string | null
    amount?: string | null
    refundable?: string | null
    currency?: string | null
    Price?: PriceCreateNestedOneWithoutFeeInput
  }

  export type FeeUncheckedCreateInput = {
    id?: string
    type?: string | null
    amount?: string | null
    refundable?: string | null
    currency?: string | null
    priceId?: string | null
  }

  export type FeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    refundable?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    Price?: PriceUpdateOneWithoutFeeNestedInput
  }

  export type FeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    refundable?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeCreateManyInput = {
    id?: string
    type?: string | null
    amount?: string | null
    refundable?: string | null
    currency?: string | null
    priceId?: string | null
  }

  export type FeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    refundable?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    refundable?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BaggageCreateInput = {
    id?: string
    quantity?: number | null
    weight?: string | null
    type?: string | null
    Passenger?: PassengerCreateNestedOneWithoutBaggageInput
  }

  export type BaggageUncheckedCreateInput = {
    id?: string
    quantity?: number | null
    weight?: string | null
    type?: string | null
    passengerId?: string | null
  }

  export type BaggageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUpdateOneWithoutBaggageNestedInput
  }

  export type BaggageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BaggageCreateManyInput = {
    id?: string
    quantity?: number | null
    weight?: string | null
    type?: string | null
    passengerId?: string | null
  }

  export type BaggageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BaggageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteCreateInput = {
    id?: string
    departIataCode?: string | null
    departTerminal?: string | null
    departAt?: string | null
    arrivalIataCode?: string | null
    arrivalTerminal?: string | null
    arrivalAt?: string | null
    flightNumber?: string | null
    aircraftCode?: string | null
    duration?: string | null
    numberOfStops?: number | null
    carrierCode?: string | null
    routeId?: string | null
    Itinerary?: ItineraryCreateNestedOneWithoutRouteInput
  }

  export type RouteUncheckedCreateInput = {
    id?: string
    departIataCode?: string | null
    departTerminal?: string | null
    departAt?: string | null
    arrivalIataCode?: string | null
    arrivalTerminal?: string | null
    arrivalAt?: string | null
    flightNumber?: string | null
    aircraftCode?: string | null
    duration?: string | null
    numberOfStops?: number | null
    carrierCode?: string | null
    routeId?: string | null
    itineraryId?: string | null
  }

  export type RouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    departTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    departAt?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalAt?: NullableStringFieldUpdateOperationsInput | string | null
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aircraftCode?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfStops?: NullableIntFieldUpdateOperationsInput | number | null
    carrierCode?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    Itinerary?: ItineraryUpdateOneWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    departTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    departAt?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalAt?: NullableStringFieldUpdateOperationsInput | string | null
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aircraftCode?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfStops?: NullableIntFieldUpdateOperationsInput | number | null
    carrierCode?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    itineraryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteCreateManyInput = {
    id?: string
    departIataCode?: string | null
    departTerminal?: string | null
    departAt?: string | null
    arrivalIataCode?: string | null
    arrivalTerminal?: string | null
    arrivalAt?: string | null
    flightNumber?: string | null
    aircraftCode?: string | null
    duration?: string | null
    numberOfStops?: number | null
    carrierCode?: string | null
    routeId?: string | null
    itineraryId?: string | null
  }

  export type RouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    departIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    departTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    departAt?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalAt?: NullableStringFieldUpdateOperationsInput | string | null
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aircraftCode?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfStops?: NullableIntFieldUpdateOperationsInput | number | null
    carrierCode?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    departTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    departAt?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalAt?: NullableStringFieldUpdateOperationsInput | string | null
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aircraftCode?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfStops?: NullableIntFieldUpdateOperationsInput | number | null
    carrierCode?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    itineraryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fareDetailsByRouteCreateInput = {
    id?: string
    routeId?: string | null
    fareBasis?: string | null
    class?: string | null
    brandedFare?: string | null
    includedCheckedBagsUnit?: number | null
    includedCheckedBagsWeight?: number | null
    includedCheckedBagsWeightUnit?: string | null
    cabin?: string | null
    Passenger?: PassengerCreateNestedOneWithoutFareDetailsByRouteInput
  }

  export type fareDetailsByRouteUncheckedCreateInput = {
    id?: string
    routeId?: string | null
    fareBasis?: string | null
    class?: string | null
    brandedFare?: string | null
    includedCheckedBagsUnit?: number | null
    includedCheckedBagsWeight?: number | null
    includedCheckedBagsWeightUnit?: string | null
    cabin?: string | null
    passengerId?: string | null
  }

  export type fareDetailsByRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    fareBasis?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    brandedFare?: NullableStringFieldUpdateOperationsInput | string | null
    includedCheckedBagsUnit?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeight?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    cabin?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUpdateOneWithoutFareDetailsByRouteNestedInput
  }

  export type fareDetailsByRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    fareBasis?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    brandedFare?: NullableStringFieldUpdateOperationsInput | string | null
    includedCheckedBagsUnit?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeight?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    cabin?: NullableStringFieldUpdateOperationsInput | string | null
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fareDetailsByRouteCreateManyInput = {
    id?: string
    routeId?: string | null
    fareBasis?: string | null
    class?: string | null
    brandedFare?: string | null
    includedCheckedBagsUnit?: number | null
    includedCheckedBagsWeight?: number | null
    includedCheckedBagsWeightUnit?: string | null
    cabin?: string | null
    passengerId?: string | null
  }

  export type fareDetailsByRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    fareBasis?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    brandedFare?: NullableStringFieldUpdateOperationsInput | string | null
    includedCheckedBagsUnit?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeight?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    cabin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fareDetailsByRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    fareBasis?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    brandedFare?: NullableStringFieldUpdateOperationsInput | string | null
    includedCheckedBagsUnit?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeight?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    cabin?: NullableStringFieldUpdateOperationsInput | string | null
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    accesstoken?: string | null
    refreshtoken?: string | null
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    accesstoken?: string | null
    refreshtoken?: string | null
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accesstoken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshtoken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accesstoken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshtoken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    password?: string | null
    accesstoken?: string | null
    refreshtoken?: string | null
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accesstoken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshtoken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    accesstoken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshtoken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentCreateInput = {
    id?: string
    enable?: boolean | null
    regionality?: string | null
    provider?: string | null
    validTill?: Date | string | null
  }

  export type paymentUncheckedCreateInput = {
    id?: string
    enable?: boolean | null
    regionality?: string | null
    provider?: string | null
    validTill?: Date | string | null
  }

  export type paymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regionality?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    validTill?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regionality?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    validTill?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentCreateManyInput = {
    id?: string
    enable?: boolean | null
    regionality?: string | null
    provider?: string | null
    validTill?: Date | string | null
  }

  export type paymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regionality?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    validTill?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    regionality?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    validTill?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type loggingCreateInput = {
    id?: string
    corelationId?: string | null
    date?: string | null
    serviceType?: string | null
    logType?: string | null
    log?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: string | null
  }

  export type loggingUncheckedCreateInput = {
    id?: string
    corelationId?: string | null
    date?: string | null
    serviceType?: string | null
    logType?: string | null
    log?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: string | null
  }

  export type loggingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    corelationId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type loggingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    corelationId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type loggingCreateManyInput = {
    id?: string
    corelationId?: string | null
    date?: string | null
    serviceType?: string | null
    logType?: string | null
    log?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: string | null
  }

  export type loggingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    corelationId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type loggingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    corelationId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: NullableStringFieldUpdateOperationsInput | string | null
    log?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type specialServiceRuleTableCountOrderByAggregateInput = {
    id?: SortOrder
    enable?: SortOrder
    currency?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    carriercode?: SortOrder
    offermeals?: SortOrder
    offerseats?: SortOrder
    Offerfrequentflyermiles?: SortOrder
    offerpricewithincludedbaggage?: SortOrder
  }

  export type specialServiceRuleTableMaxOrderByAggregateInput = {
    id?: SortOrder
    enable?: SortOrder
    currency?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    carriercode?: SortOrder
    offermeals?: SortOrder
    offerseats?: SortOrder
    Offerfrequentflyermiles?: SortOrder
    offerpricewithincludedbaggage?: SortOrder
  }

  export type specialServiceRuleTableMinOrderByAggregateInput = {
    id?: SortOrder
    enable?: SortOrder
    currency?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    carriercode?: SortOrder
    offermeals?: SortOrder
    offerseats?: SortOrder
    Offerfrequentflyermiles?: SortOrder
    offerpricewithincludedbaggage?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type locationsCountOrderByAggregateInput = {
    id?: SortOrder
    iata?: SortOrder
    cityName?: SortOrder
    airportName?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    icon?: SortOrder
  }

  export type locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    iata?: SortOrder
    cityName?: SortOrder
    airportName?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    icon?: SortOrder
  }

  export type locationsMinOrderByAggregateInput = {
    id?: SortOrder
    iata?: SortOrder
    cityName?: SortOrder
    airportName?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    icon?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type PassengerListRelationFilter = {
    every?: PassengerWhereInput
    some?: PassengerWhereInput
    none?: PassengerWhereInput
  }

  export type ItineraryListRelationFilter = {
    every?: ItineraryWhereInput
    some?: ItineraryWhereInput
    none?: ItineraryWhereInput
  }

  export type PriceListRelationFilter = {
    every?: PriceWhereInput
    some?: PriceWhereInput
    none?: PriceWhereInput
  }

  export type PassengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderRef?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    paymentIntentId?: SortOrder
    paymentStatus?: SortOrder
    supplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeSessionId?: SortOrder
    razorpayOrderId?: SortOrder
    flightOfferId?: SortOrder
    flightInternalSource?: SortOrder
    userEmail?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderRef?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    paymentIntentId?: SortOrder
    paymentStatus?: SortOrder
    supplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeSessionId?: SortOrder
    razorpayOrderId?: SortOrder
    flightOfferId?: SortOrder
    flightInternalSource?: SortOrder
    userEmail?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderRef?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    paymentIntentId?: SortOrder
    paymentStatus?: SortOrder
    supplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeSessionId?: SortOrder
    razorpayOrderId?: SortOrder
    flightOfferId?: SortOrder
    flightInternalSource?: SortOrder
    userEmail?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type BaggageListRelationFilter = {
    every?: BaggageWhereInput
    some?: BaggageWhereInput
    none?: BaggageWhereInput
  }

  export type FareDetailsByRouteListRelationFilter = {
    every?: fareDetailsByRouteWhereInput
    some?: fareDetailsByRouteWhereInput
    none?: fareDetailsByRouteWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BaggageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fareDetailsByRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PassengerCountOrderByAggregateInput = {
    id?: SortOrder
    passengerId?: SortOrder
    countryCode?: SortOrder
    email?: SortOrder
    dateOfBirth?: SortOrder
    passengerType?: SortOrder
    title?: SortOrder
    gender?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    seatNumber?: SortOrder
    fareOption?: SortOrder
    bookingId?: SortOrder
    phone?: SortOrder
  }

  export type PassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    passengerId?: SortOrder
    countryCode?: SortOrder
    email?: SortOrder
    dateOfBirth?: SortOrder
    passengerType?: SortOrder
    title?: SortOrder
    gender?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    seatNumber?: SortOrder
    fareOption?: SortOrder
    bookingId?: SortOrder
    phone?: SortOrder
  }

  export type PassengerMinOrderByAggregateInput = {
    id?: SortOrder
    passengerId?: SortOrder
    countryCode?: SortOrder
    email?: SortOrder
    dateOfBirth?: SortOrder
    passengerType?: SortOrder
    title?: SortOrder
    gender?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    seatNumber?: SortOrder
    fareOption?: SortOrder
    bookingId?: SortOrder
    phone?: SortOrder
  }

  export type RouteListRelationFilter = {
    every?: RouteWhereInput
    some?: RouteWhereInput
    none?: RouteWhereInput
  }

  export type RouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryCountOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    bookingId?: SortOrder
  }

  export type ItineraryMaxOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    bookingId?: SortOrder
  }

  export type ItineraryMinOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    bookingId?: SortOrder
  }

  export type PassengerRelationFilter = {
    is?: PassengerWhereInput | null
    isNot?: PassengerWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issuanceDate?: SortOrder
    expiryDate?: SortOrder
    issuanceCountryCode?: SortOrder
    issuanceLocation?: SortOrder
    nationality?: SortOrder
    documentType?: SortOrder
    passengerId?: SortOrder
    holder?: SortOrder
    birthPlace?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issuanceDate?: SortOrder
    expiryDate?: SortOrder
    issuanceCountryCode?: SortOrder
    issuanceLocation?: SortOrder
    nationality?: SortOrder
    documentType?: SortOrder
    passengerId?: SortOrder
    holder?: SortOrder
    birthPlace?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    issuanceDate?: SortOrder
    expiryDate?: SortOrder
    issuanceCountryCode?: SortOrder
    issuanceLocation?: SortOrder
    nationality?: SortOrder
    documentType?: SortOrder
    passengerId?: SortOrder
    holder?: SortOrder
    birthPlace?: SortOrder
  }

  export type FeeListRelationFilter = {
    every?: FeeWhereInput
    some?: FeeWhereInput
    none?: FeeWhereInput
  }

  export type FeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceCountOrderByAggregateInput = {
    id?: SortOrder
    basePrice?: SortOrder
    grandTotal?: SortOrder
    discountAmt?: SortOrder
    commissionAmt?: SortOrder
    currency?: SortOrder
    bookingId?: SortOrder
  }

  export type PriceMaxOrderByAggregateInput = {
    id?: SortOrder
    basePrice?: SortOrder
    grandTotal?: SortOrder
    discountAmt?: SortOrder
    commissionAmt?: SortOrder
    currency?: SortOrder
    bookingId?: SortOrder
  }

  export type PriceMinOrderByAggregateInput = {
    id?: SortOrder
    basePrice?: SortOrder
    grandTotal?: SortOrder
    discountAmt?: SortOrder
    commissionAmt?: SortOrder
    currency?: SortOrder
    bookingId?: SortOrder
  }

  export type PriceRelationFilter = {
    is?: PriceWhereInput | null
    isNot?: PriceWhereInput | null
  }

  export type FeeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    refundable?: SortOrder
    currency?: SortOrder
    priceId?: SortOrder
  }

  export type FeeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    refundable?: SortOrder
    currency?: SortOrder
    priceId?: SortOrder
  }

  export type FeeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    refundable?: SortOrder
    currency?: SortOrder
    priceId?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BaggageCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    type?: SortOrder
    passengerId?: SortOrder
  }

  export type BaggageAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type BaggageMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    type?: SortOrder
    passengerId?: SortOrder
  }

  export type BaggageMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    type?: SortOrder
    passengerId?: SortOrder
  }

  export type BaggageSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type ItineraryRelationFilter = {
    is?: ItineraryWhereInput | null
    isNot?: ItineraryWhereInput | null
  }

  export type RouteCountOrderByAggregateInput = {
    id?: SortOrder
    departIataCode?: SortOrder
    departTerminal?: SortOrder
    departAt?: SortOrder
    arrivalIataCode?: SortOrder
    arrivalTerminal?: SortOrder
    arrivalAt?: SortOrder
    flightNumber?: SortOrder
    aircraftCode?: SortOrder
    duration?: SortOrder
    numberOfStops?: SortOrder
    carrierCode?: SortOrder
    routeId?: SortOrder
    itineraryId?: SortOrder
  }

  export type RouteAvgOrderByAggregateInput = {
    numberOfStops?: SortOrder
  }

  export type RouteMaxOrderByAggregateInput = {
    id?: SortOrder
    departIataCode?: SortOrder
    departTerminal?: SortOrder
    departAt?: SortOrder
    arrivalIataCode?: SortOrder
    arrivalTerminal?: SortOrder
    arrivalAt?: SortOrder
    flightNumber?: SortOrder
    aircraftCode?: SortOrder
    duration?: SortOrder
    numberOfStops?: SortOrder
    carrierCode?: SortOrder
    routeId?: SortOrder
    itineraryId?: SortOrder
  }

  export type RouteMinOrderByAggregateInput = {
    id?: SortOrder
    departIataCode?: SortOrder
    departTerminal?: SortOrder
    departAt?: SortOrder
    arrivalIataCode?: SortOrder
    arrivalTerminal?: SortOrder
    arrivalAt?: SortOrder
    flightNumber?: SortOrder
    aircraftCode?: SortOrder
    duration?: SortOrder
    numberOfStops?: SortOrder
    carrierCode?: SortOrder
    routeId?: SortOrder
    itineraryId?: SortOrder
  }

  export type RouteSumOrderByAggregateInput = {
    numberOfStops?: SortOrder
  }

  export type fareDetailsByRouteCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    fareBasis?: SortOrder
    class?: SortOrder
    brandedFare?: SortOrder
    includedCheckedBagsUnit?: SortOrder
    includedCheckedBagsWeight?: SortOrder
    includedCheckedBagsWeightUnit?: SortOrder
    cabin?: SortOrder
    passengerId?: SortOrder
  }

  export type fareDetailsByRouteAvgOrderByAggregateInput = {
    includedCheckedBagsUnit?: SortOrder
    includedCheckedBagsWeight?: SortOrder
  }

  export type fareDetailsByRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    fareBasis?: SortOrder
    class?: SortOrder
    brandedFare?: SortOrder
    includedCheckedBagsUnit?: SortOrder
    includedCheckedBagsWeight?: SortOrder
    includedCheckedBagsWeightUnit?: SortOrder
    cabin?: SortOrder
    passengerId?: SortOrder
  }

  export type fareDetailsByRouteMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    fareBasis?: SortOrder
    class?: SortOrder
    brandedFare?: SortOrder
    includedCheckedBagsUnit?: SortOrder
    includedCheckedBagsWeight?: SortOrder
    includedCheckedBagsWeightUnit?: SortOrder
    cabin?: SortOrder
    passengerId?: SortOrder
  }

  export type fareDetailsByRouteSumOrderByAggregateInput = {
    includedCheckedBagsUnit?: SortOrder
    includedCheckedBagsWeight?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    accesstoken?: SortOrder
    refreshtoken?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    accesstoken?: SortOrder
    refreshtoken?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    accesstoken?: SortOrder
    refreshtoken?: SortOrder
  }

  export type paymentCountOrderByAggregateInput = {
    id?: SortOrder
    enable?: SortOrder
    regionality?: SortOrder
    provider?: SortOrder
    validTill?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    enable?: SortOrder
    regionality?: SortOrder
    provider?: SortOrder
    validTill?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    id?: SortOrder
    enable?: SortOrder
    regionality?: SortOrder
    provider?: SortOrder
    validTill?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type loggingCountOrderByAggregateInput = {
    id?: SortOrder
    corelationId?: SortOrder
    date?: SortOrder
    serviceType?: SortOrder
    logType?: SortOrder
    log?: SortOrder
    bookingId?: SortOrder
  }

  export type loggingMaxOrderByAggregateInput = {
    id?: SortOrder
    corelationId?: SortOrder
    date?: SortOrder
    serviceType?: SortOrder
    logType?: SortOrder
    bookingId?: SortOrder
  }

  export type loggingMinOrderByAggregateInput = {
    id?: SortOrder
    corelationId?: SortOrder
    date?: SortOrder
    serviceType?: SortOrder
    logType?: SortOrder
    bookingId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PassengerCreateNestedManyWithoutBookingInput = {
    create?: XOR<Enumerable<PassengerCreateWithoutBookingInput>, Enumerable<PassengerUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PassengerCreateOrConnectWithoutBookingInput>
    createMany?: PassengerCreateManyBookingInputEnvelope
    connect?: Enumerable<PassengerWhereUniqueInput>
  }

  export type ItineraryCreateNestedManyWithoutBookingInput = {
    create?: XOR<Enumerable<ItineraryCreateWithoutBookingInput>, Enumerable<ItineraryUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<ItineraryCreateOrConnectWithoutBookingInput>
    createMany?: ItineraryCreateManyBookingInputEnvelope
    connect?: Enumerable<ItineraryWhereUniqueInput>
  }

  export type PriceCreateNestedManyWithoutBookingInput = {
    create?: XOR<Enumerable<PriceCreateWithoutBookingInput>, Enumerable<PriceUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutBookingInput>
    createMany?: PriceCreateManyBookingInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type PassengerUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<Enumerable<PassengerCreateWithoutBookingInput>, Enumerable<PassengerUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PassengerCreateOrConnectWithoutBookingInput>
    createMany?: PassengerCreateManyBookingInputEnvelope
    connect?: Enumerable<PassengerWhereUniqueInput>
  }

  export type ItineraryUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<Enumerable<ItineraryCreateWithoutBookingInput>, Enumerable<ItineraryUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<ItineraryCreateOrConnectWithoutBookingInput>
    createMany?: ItineraryCreateManyBookingInputEnvelope
    connect?: Enumerable<ItineraryWhereUniqueInput>
  }

  export type PriceUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<Enumerable<PriceCreateWithoutBookingInput>, Enumerable<PriceUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutBookingInput>
    createMany?: PriceCreateManyBookingInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PassengerUpdateManyWithoutBookingNestedInput = {
    create?: XOR<Enumerable<PassengerCreateWithoutBookingInput>, Enumerable<PassengerUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PassengerCreateOrConnectWithoutBookingInput>
    upsert?: Enumerable<PassengerUpsertWithWhereUniqueWithoutBookingInput>
    createMany?: PassengerCreateManyBookingInputEnvelope
    set?: Enumerable<PassengerWhereUniqueInput>
    disconnect?: Enumerable<PassengerWhereUniqueInput>
    delete?: Enumerable<PassengerWhereUniqueInput>
    connect?: Enumerable<PassengerWhereUniqueInput>
    update?: Enumerable<PassengerUpdateWithWhereUniqueWithoutBookingInput>
    updateMany?: Enumerable<PassengerUpdateManyWithWhereWithoutBookingInput>
    deleteMany?: Enumerable<PassengerScalarWhereInput>
  }

  export type ItineraryUpdateManyWithoutBookingNestedInput = {
    create?: XOR<Enumerable<ItineraryCreateWithoutBookingInput>, Enumerable<ItineraryUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<ItineraryCreateOrConnectWithoutBookingInput>
    upsert?: Enumerable<ItineraryUpsertWithWhereUniqueWithoutBookingInput>
    createMany?: ItineraryCreateManyBookingInputEnvelope
    set?: Enumerable<ItineraryWhereUniqueInput>
    disconnect?: Enumerable<ItineraryWhereUniqueInput>
    delete?: Enumerable<ItineraryWhereUniqueInput>
    connect?: Enumerable<ItineraryWhereUniqueInput>
    update?: Enumerable<ItineraryUpdateWithWhereUniqueWithoutBookingInput>
    updateMany?: Enumerable<ItineraryUpdateManyWithWhereWithoutBookingInput>
    deleteMany?: Enumerable<ItineraryScalarWhereInput>
  }

  export type PriceUpdateManyWithoutBookingNestedInput = {
    create?: XOR<Enumerable<PriceCreateWithoutBookingInput>, Enumerable<PriceUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutBookingInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutBookingInput>
    createMany?: PriceCreateManyBookingInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutBookingInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutBookingInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type PassengerUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<Enumerable<PassengerCreateWithoutBookingInput>, Enumerable<PassengerUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PassengerCreateOrConnectWithoutBookingInput>
    upsert?: Enumerable<PassengerUpsertWithWhereUniqueWithoutBookingInput>
    createMany?: PassengerCreateManyBookingInputEnvelope
    set?: Enumerable<PassengerWhereUniqueInput>
    disconnect?: Enumerable<PassengerWhereUniqueInput>
    delete?: Enumerable<PassengerWhereUniqueInput>
    connect?: Enumerable<PassengerWhereUniqueInput>
    update?: Enumerable<PassengerUpdateWithWhereUniqueWithoutBookingInput>
    updateMany?: Enumerable<PassengerUpdateManyWithWhereWithoutBookingInput>
    deleteMany?: Enumerable<PassengerScalarWhereInput>
  }

  export type ItineraryUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<Enumerable<ItineraryCreateWithoutBookingInput>, Enumerable<ItineraryUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<ItineraryCreateOrConnectWithoutBookingInput>
    upsert?: Enumerable<ItineraryUpsertWithWhereUniqueWithoutBookingInput>
    createMany?: ItineraryCreateManyBookingInputEnvelope
    set?: Enumerable<ItineraryWhereUniqueInput>
    disconnect?: Enumerable<ItineraryWhereUniqueInput>
    delete?: Enumerable<ItineraryWhereUniqueInput>
    connect?: Enumerable<ItineraryWhereUniqueInput>
    update?: Enumerable<ItineraryUpdateWithWhereUniqueWithoutBookingInput>
    updateMany?: Enumerable<ItineraryUpdateManyWithWhereWithoutBookingInput>
    deleteMany?: Enumerable<ItineraryScalarWhereInput>
  }

  export type PriceUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<Enumerable<PriceCreateWithoutBookingInput>, Enumerable<PriceUncheckedCreateWithoutBookingInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutBookingInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutBookingInput>
    createMany?: PriceCreateManyBookingInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutBookingInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutBookingInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type BookingCreateNestedOneWithoutPassengerInput = {
    create?: XOR<BookingCreateWithoutPassengerInput, BookingUncheckedCreateWithoutPassengerInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengerInput
    connect?: BookingWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutPassengerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutPassengerInput>, Enumerable<DocumentUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutPassengerInput>
    createMany?: DocumentCreateManyPassengerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type BaggageCreateNestedManyWithoutPassengerInput = {
    create?: XOR<Enumerable<BaggageCreateWithoutPassengerInput>, Enumerable<BaggageUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<BaggageCreateOrConnectWithoutPassengerInput>
    createMany?: BaggageCreateManyPassengerInputEnvelope
    connect?: Enumerable<BaggageWhereUniqueInput>
  }

  export type fareDetailsByRouteCreateNestedManyWithoutPassengerInput = {
    create?: XOR<Enumerable<fareDetailsByRouteCreateWithoutPassengerInput>, Enumerable<fareDetailsByRouteUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<fareDetailsByRouteCreateOrConnectWithoutPassengerInput>
    createMany?: fareDetailsByRouteCreateManyPassengerInputEnvelope
    connect?: Enumerable<fareDetailsByRouteWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutPassengerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutPassengerInput>, Enumerable<DocumentUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutPassengerInput>
    createMany?: DocumentCreateManyPassengerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type BaggageUncheckedCreateNestedManyWithoutPassengerInput = {
    create?: XOR<Enumerable<BaggageCreateWithoutPassengerInput>, Enumerable<BaggageUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<BaggageCreateOrConnectWithoutPassengerInput>
    createMany?: BaggageCreateManyPassengerInputEnvelope
    connect?: Enumerable<BaggageWhereUniqueInput>
  }

  export type fareDetailsByRouteUncheckedCreateNestedManyWithoutPassengerInput = {
    create?: XOR<Enumerable<fareDetailsByRouteCreateWithoutPassengerInput>, Enumerable<fareDetailsByRouteUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<fareDetailsByRouteCreateOrConnectWithoutPassengerInput>
    createMany?: fareDetailsByRouteCreateManyPassengerInputEnvelope
    connect?: Enumerable<fareDetailsByRouteWhereUniqueInput>
  }

  export type BookingUpdateOneWithoutPassengerNestedInput = {
    create?: XOR<BookingCreateWithoutPassengerInput, BookingUncheckedCreateWithoutPassengerInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengerInput
    upsert?: BookingUpsertWithoutPassengerInput
    disconnect?: boolean
    delete?: boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<BookingUpdateWithoutPassengerInput, BookingUncheckedUpdateWithoutPassengerInput>
  }

  export type DocumentUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutPassengerInput>, Enumerable<DocumentUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutPassengerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutPassengerInput>
    createMany?: DocumentCreateManyPassengerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutPassengerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutPassengerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type BaggageUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<Enumerable<BaggageCreateWithoutPassengerInput>, Enumerable<BaggageUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<BaggageCreateOrConnectWithoutPassengerInput>
    upsert?: Enumerable<BaggageUpsertWithWhereUniqueWithoutPassengerInput>
    createMany?: BaggageCreateManyPassengerInputEnvelope
    set?: Enumerable<BaggageWhereUniqueInput>
    disconnect?: Enumerable<BaggageWhereUniqueInput>
    delete?: Enumerable<BaggageWhereUniqueInput>
    connect?: Enumerable<BaggageWhereUniqueInput>
    update?: Enumerable<BaggageUpdateWithWhereUniqueWithoutPassengerInput>
    updateMany?: Enumerable<BaggageUpdateManyWithWhereWithoutPassengerInput>
    deleteMany?: Enumerable<BaggageScalarWhereInput>
  }

  export type fareDetailsByRouteUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<Enumerable<fareDetailsByRouteCreateWithoutPassengerInput>, Enumerable<fareDetailsByRouteUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<fareDetailsByRouteCreateOrConnectWithoutPassengerInput>
    upsert?: Enumerable<fareDetailsByRouteUpsertWithWhereUniqueWithoutPassengerInput>
    createMany?: fareDetailsByRouteCreateManyPassengerInputEnvelope
    set?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    disconnect?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    delete?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    connect?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    update?: Enumerable<fareDetailsByRouteUpdateWithWhereUniqueWithoutPassengerInput>
    updateMany?: Enumerable<fareDetailsByRouteUpdateManyWithWhereWithoutPassengerInput>
    deleteMany?: Enumerable<fareDetailsByRouteScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutPassengerInput>, Enumerable<DocumentUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutPassengerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutPassengerInput>
    createMany?: DocumentCreateManyPassengerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutPassengerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutPassengerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type BaggageUncheckedUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<Enumerable<BaggageCreateWithoutPassengerInput>, Enumerable<BaggageUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<BaggageCreateOrConnectWithoutPassengerInput>
    upsert?: Enumerable<BaggageUpsertWithWhereUniqueWithoutPassengerInput>
    createMany?: BaggageCreateManyPassengerInputEnvelope
    set?: Enumerable<BaggageWhereUniqueInput>
    disconnect?: Enumerable<BaggageWhereUniqueInput>
    delete?: Enumerable<BaggageWhereUniqueInput>
    connect?: Enumerable<BaggageWhereUniqueInput>
    update?: Enumerable<BaggageUpdateWithWhereUniqueWithoutPassengerInput>
    updateMany?: Enumerable<BaggageUpdateManyWithWhereWithoutPassengerInput>
    deleteMany?: Enumerable<BaggageScalarWhereInput>
  }

  export type fareDetailsByRouteUncheckedUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<Enumerable<fareDetailsByRouteCreateWithoutPassengerInput>, Enumerable<fareDetailsByRouteUncheckedCreateWithoutPassengerInput>>
    connectOrCreate?: Enumerable<fareDetailsByRouteCreateOrConnectWithoutPassengerInput>
    upsert?: Enumerable<fareDetailsByRouteUpsertWithWhereUniqueWithoutPassengerInput>
    createMany?: fareDetailsByRouteCreateManyPassengerInputEnvelope
    set?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    disconnect?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    delete?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    connect?: Enumerable<fareDetailsByRouteWhereUniqueInput>
    update?: Enumerable<fareDetailsByRouteUpdateWithWhereUniqueWithoutPassengerInput>
    updateMany?: Enumerable<fareDetailsByRouteUpdateManyWithWhereWithoutPassengerInput>
    deleteMany?: Enumerable<fareDetailsByRouteScalarWhereInput>
  }

  export type BookingCreateNestedOneWithoutItineraryInput = {
    create?: XOR<BookingCreateWithoutItineraryInput, BookingUncheckedCreateWithoutItineraryInput>
    connectOrCreate?: BookingCreateOrConnectWithoutItineraryInput
    connect?: BookingWhereUniqueInput
  }

  export type RouteCreateNestedManyWithoutItineraryInput = {
    create?: XOR<Enumerable<RouteCreateWithoutItineraryInput>, Enumerable<RouteUncheckedCreateWithoutItineraryInput>>
    connectOrCreate?: Enumerable<RouteCreateOrConnectWithoutItineraryInput>
    createMany?: RouteCreateManyItineraryInputEnvelope
    connect?: Enumerable<RouteWhereUniqueInput>
  }

  export type RouteUncheckedCreateNestedManyWithoutItineraryInput = {
    create?: XOR<Enumerable<RouteCreateWithoutItineraryInput>, Enumerable<RouteUncheckedCreateWithoutItineraryInput>>
    connectOrCreate?: Enumerable<RouteCreateOrConnectWithoutItineraryInput>
    createMany?: RouteCreateManyItineraryInputEnvelope
    connect?: Enumerable<RouteWhereUniqueInput>
  }

  export type BookingUpdateOneWithoutItineraryNestedInput = {
    create?: XOR<BookingCreateWithoutItineraryInput, BookingUncheckedCreateWithoutItineraryInput>
    connectOrCreate?: BookingCreateOrConnectWithoutItineraryInput
    upsert?: BookingUpsertWithoutItineraryInput
    disconnect?: boolean
    delete?: boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<BookingUpdateWithoutItineraryInput, BookingUncheckedUpdateWithoutItineraryInput>
  }

  export type RouteUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<Enumerable<RouteCreateWithoutItineraryInput>, Enumerable<RouteUncheckedCreateWithoutItineraryInput>>
    connectOrCreate?: Enumerable<RouteCreateOrConnectWithoutItineraryInput>
    upsert?: Enumerable<RouteUpsertWithWhereUniqueWithoutItineraryInput>
    createMany?: RouteCreateManyItineraryInputEnvelope
    set?: Enumerable<RouteWhereUniqueInput>
    disconnect?: Enumerable<RouteWhereUniqueInput>
    delete?: Enumerable<RouteWhereUniqueInput>
    connect?: Enumerable<RouteWhereUniqueInput>
    update?: Enumerable<RouteUpdateWithWhereUniqueWithoutItineraryInput>
    updateMany?: Enumerable<RouteUpdateManyWithWhereWithoutItineraryInput>
    deleteMany?: Enumerable<RouteScalarWhereInput>
  }

  export type RouteUncheckedUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<Enumerable<RouteCreateWithoutItineraryInput>, Enumerable<RouteUncheckedCreateWithoutItineraryInput>>
    connectOrCreate?: Enumerable<RouteCreateOrConnectWithoutItineraryInput>
    upsert?: Enumerable<RouteUpsertWithWhereUniqueWithoutItineraryInput>
    createMany?: RouteCreateManyItineraryInputEnvelope
    set?: Enumerable<RouteWhereUniqueInput>
    disconnect?: Enumerable<RouteWhereUniqueInput>
    delete?: Enumerable<RouteWhereUniqueInput>
    connect?: Enumerable<RouteWhereUniqueInput>
    update?: Enumerable<RouteUpdateWithWhereUniqueWithoutItineraryInput>
    updateMany?: Enumerable<RouteUpdateManyWithWhereWithoutItineraryInput>
    deleteMany?: Enumerable<RouteScalarWhereInput>
  }

  export type PassengerCreateNestedOneWithoutDocumentInput = {
    create?: XOR<PassengerCreateWithoutDocumentInput, PassengerUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PassengerCreateOrConnectWithoutDocumentInput
    connect?: PassengerWhereUniqueInput
  }

  export type PassengerUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<PassengerCreateWithoutDocumentInput, PassengerUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PassengerCreateOrConnectWithoutDocumentInput
    upsert?: PassengerUpsertWithoutDocumentInput
    disconnect?: boolean
    delete?: boolean
    connect?: PassengerWhereUniqueInput
    update?: XOR<PassengerUpdateWithoutDocumentInput, PassengerUncheckedUpdateWithoutDocumentInput>
  }

  export type BookingCreateNestedOneWithoutPriceInput = {
    create?: XOR<BookingCreateWithoutPriceInput, BookingUncheckedCreateWithoutPriceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPriceInput
    connect?: BookingWhereUniqueInput
  }

  export type FeeCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<FeeCreateWithoutPriceInput>, Enumerable<FeeUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<FeeCreateOrConnectWithoutPriceInput>
    createMany?: FeeCreateManyPriceInputEnvelope
    connect?: Enumerable<FeeWhereUniqueInput>
  }

  export type FeeUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<FeeCreateWithoutPriceInput>, Enumerable<FeeUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<FeeCreateOrConnectWithoutPriceInput>
    createMany?: FeeCreateManyPriceInputEnvelope
    connect?: Enumerable<FeeWhereUniqueInput>
  }

  export type BookingUpdateOneWithoutPriceNestedInput = {
    create?: XOR<BookingCreateWithoutPriceInput, BookingUncheckedCreateWithoutPriceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPriceInput
    upsert?: BookingUpsertWithoutPriceInput
    disconnect?: boolean
    delete?: boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<BookingUpdateWithoutPriceInput, BookingUncheckedUpdateWithoutPriceInput>
  }

  export type FeeUpdateManyWithoutPriceNestedInput = {
    create?: XOR<Enumerable<FeeCreateWithoutPriceInput>, Enumerable<FeeUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<FeeCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<FeeUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: FeeCreateManyPriceInputEnvelope
    set?: Enumerable<FeeWhereUniqueInput>
    disconnect?: Enumerable<FeeWhereUniqueInput>
    delete?: Enumerable<FeeWhereUniqueInput>
    connect?: Enumerable<FeeWhereUniqueInput>
    update?: Enumerable<FeeUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<FeeUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<FeeScalarWhereInput>
  }

  export type FeeUncheckedUpdateManyWithoutPriceNestedInput = {
    create?: XOR<Enumerable<FeeCreateWithoutPriceInput>, Enumerable<FeeUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<FeeCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<FeeUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: FeeCreateManyPriceInputEnvelope
    set?: Enumerable<FeeWhereUniqueInput>
    disconnect?: Enumerable<FeeWhereUniqueInput>
    delete?: Enumerable<FeeWhereUniqueInput>
    connect?: Enumerable<FeeWhereUniqueInput>
    update?: Enumerable<FeeUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<FeeUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<FeeScalarWhereInput>
  }

  export type PriceCreateNestedOneWithoutFeeInput = {
    create?: XOR<PriceCreateWithoutFeeInput, PriceUncheckedCreateWithoutFeeInput>
    connectOrCreate?: PriceCreateOrConnectWithoutFeeInput
    connect?: PriceWhereUniqueInput
  }

  export type PriceUpdateOneWithoutFeeNestedInput = {
    create?: XOR<PriceCreateWithoutFeeInput, PriceUncheckedCreateWithoutFeeInput>
    connectOrCreate?: PriceCreateOrConnectWithoutFeeInput
    upsert?: PriceUpsertWithoutFeeInput
    disconnect?: boolean
    delete?: boolean
    connect?: PriceWhereUniqueInput
    update?: XOR<PriceUpdateWithoutFeeInput, PriceUncheckedUpdateWithoutFeeInput>
  }

  export type PassengerCreateNestedOneWithoutBaggageInput = {
    create?: XOR<PassengerCreateWithoutBaggageInput, PassengerUncheckedCreateWithoutBaggageInput>
    connectOrCreate?: PassengerCreateOrConnectWithoutBaggageInput
    connect?: PassengerWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PassengerUpdateOneWithoutBaggageNestedInput = {
    create?: XOR<PassengerCreateWithoutBaggageInput, PassengerUncheckedCreateWithoutBaggageInput>
    connectOrCreate?: PassengerCreateOrConnectWithoutBaggageInput
    upsert?: PassengerUpsertWithoutBaggageInput
    disconnect?: boolean
    delete?: boolean
    connect?: PassengerWhereUniqueInput
    update?: XOR<PassengerUpdateWithoutBaggageInput, PassengerUncheckedUpdateWithoutBaggageInput>
  }

  export type ItineraryCreateNestedOneWithoutRouteInput = {
    create?: XOR<ItineraryCreateWithoutRouteInput, ItineraryUncheckedCreateWithoutRouteInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutRouteInput
    connect?: ItineraryWhereUniqueInput
  }

  export type ItineraryUpdateOneWithoutRouteNestedInput = {
    create?: XOR<ItineraryCreateWithoutRouteInput, ItineraryUncheckedCreateWithoutRouteInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutRouteInput
    upsert?: ItineraryUpsertWithoutRouteInput
    disconnect?: boolean
    delete?: boolean
    connect?: ItineraryWhereUniqueInput
    update?: XOR<ItineraryUpdateWithoutRouteInput, ItineraryUncheckedUpdateWithoutRouteInput>
  }

  export type PassengerCreateNestedOneWithoutFareDetailsByRouteInput = {
    create?: XOR<PassengerCreateWithoutFareDetailsByRouteInput, PassengerUncheckedCreateWithoutFareDetailsByRouteInput>
    connectOrCreate?: PassengerCreateOrConnectWithoutFareDetailsByRouteInput
    connect?: PassengerWhereUniqueInput
  }

  export type PassengerUpdateOneWithoutFareDetailsByRouteNestedInput = {
    create?: XOR<PassengerCreateWithoutFareDetailsByRouteInput, PassengerUncheckedCreateWithoutFareDetailsByRouteInput>
    connectOrCreate?: PassengerCreateOrConnectWithoutFareDetailsByRouteInput
    upsert?: PassengerUpsertWithoutFareDetailsByRouteInput
    disconnect?: boolean
    delete?: boolean
    connect?: PassengerWhereUniqueInput
    update?: XOR<PassengerUpdateWithoutFareDetailsByRouteInput, PassengerUncheckedUpdateWithoutFareDetailsByRouteInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type PassengerCreateWithoutBookingInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    phone?: string | null
    Document?: DocumentCreateNestedManyWithoutPassengerInput
    Baggage?: BaggageCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteCreateNestedManyWithoutPassengerInput
  }

  export type PassengerUncheckedCreateWithoutBookingInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    phone?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutPassengerInput
    Baggage?: BaggageUncheckedCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type PassengerCreateOrConnectWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    create: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput>
  }

  export type PassengerCreateManyBookingInputEnvelope = {
    data: Enumerable<PassengerCreateManyBookingInput>
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutBookingInput = {
    id?: string
    duration?: string | null
    Route?: RouteCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutBookingInput = {
    id?: string
    duration?: string | null
    Route?: RouteUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutBookingInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutBookingInput, ItineraryUncheckedCreateWithoutBookingInput>
  }

  export type ItineraryCreateManyBookingInputEnvelope = {
    data: Enumerable<ItineraryCreateManyBookingInput>
    skipDuplicates?: boolean
  }

  export type PriceCreateWithoutBookingInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
    Fee?: FeeCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateWithoutBookingInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
    Fee?: FeeUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceCreateOrConnectWithoutBookingInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutBookingInput, PriceUncheckedCreateWithoutBookingInput>
  }

  export type PriceCreateManyBookingInputEnvelope = {
    data: Enumerable<PriceCreateManyBookingInput>
    skipDuplicates?: boolean
  }

  export type PassengerUpsertWithWhereUniqueWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    update: XOR<PassengerUpdateWithoutBookingInput, PassengerUncheckedUpdateWithoutBookingInput>
    create: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput>
  }

  export type PassengerUpdateWithWhereUniqueWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    data: XOR<PassengerUpdateWithoutBookingInput, PassengerUncheckedUpdateWithoutBookingInput>
  }

  export type PassengerUpdateManyWithWhereWithoutBookingInput = {
    where: PassengerScalarWhereInput
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyWithoutPassengerInput>
  }

  export type PassengerScalarWhereInput = {
    AND?: Enumerable<PassengerScalarWhereInput>
    OR?: Enumerable<PassengerScalarWhereInput>
    NOT?: Enumerable<PassengerScalarWhereInput>
    id?: StringFilter | string
    passengerId?: StringNullableFilter | string | null
    countryCode?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    dateOfBirth?: StringNullableFilter | string | null
    passengerType?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    gender?: StringNullableFilter | string | null
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    seatNumber?: StringNullableFilter | string | null
    fareOption?: StringNullableFilter | string | null
    bookingId?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
  }

  export type ItineraryUpsertWithWhereUniqueWithoutBookingInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutBookingInput, ItineraryUncheckedUpdateWithoutBookingInput>
    create: XOR<ItineraryCreateWithoutBookingInput, ItineraryUncheckedCreateWithoutBookingInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutBookingInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutBookingInput, ItineraryUncheckedUpdateWithoutBookingInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutBookingInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutItineraryInput>
  }

  export type ItineraryScalarWhereInput = {
    AND?: Enumerable<ItineraryScalarWhereInput>
    OR?: Enumerable<ItineraryScalarWhereInput>
    NOT?: Enumerable<ItineraryScalarWhereInput>
    id?: StringFilter | string
    duration?: StringNullableFilter | string | null
    bookingId?: StringNullableFilter | string | null
  }

  export type PriceUpsertWithWhereUniqueWithoutBookingInput = {
    where: PriceWhereUniqueInput
    update: XOR<PriceUpdateWithoutBookingInput, PriceUncheckedUpdateWithoutBookingInput>
    create: XOR<PriceCreateWithoutBookingInput, PriceUncheckedCreateWithoutBookingInput>
  }

  export type PriceUpdateWithWhereUniqueWithoutBookingInput = {
    where: PriceWhereUniqueInput
    data: XOR<PriceUpdateWithoutBookingInput, PriceUncheckedUpdateWithoutBookingInput>
  }

  export type PriceUpdateManyWithWhereWithoutBookingInput = {
    where: PriceScalarWhereInput
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyWithoutPriceInput>
  }

  export type PriceScalarWhereInput = {
    AND?: Enumerable<PriceScalarWhereInput>
    OR?: Enumerable<PriceScalarWhereInput>
    NOT?: Enumerable<PriceScalarWhereInput>
    id?: StringFilter | string
    basePrice?: StringNullableFilter | string | null
    grandTotal?: StringNullableFilter | string | null
    discountAmt?: StringNullableFilter | string | null
    commissionAmt?: StringNullableFilter | string | null
    currency?: StringNullableFilter | string | null
    bookingId?: StringNullableFilter | string | null
  }

  export type BookingCreateWithoutPassengerInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Itinerary?: ItineraryCreateNestedManyWithoutBookingInput
    Price?: PriceCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPassengerInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Itinerary?: ItineraryUncheckedCreateNestedManyWithoutBookingInput
    Price?: PriceUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPassengerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPassengerInput, BookingUncheckedCreateWithoutPassengerInput>
  }

  export type DocumentCreateWithoutPassengerInput = {
    id?: string
    number?: string | null
    issuanceDate?: string | null
    expiryDate?: string | null
    issuanceCountryCode?: string | null
    issuanceLocation?: string | null
    nationality?: string | null
    documentType?: string | null
    holder?: boolean | null
    birthPlace?: string | null
  }

  export type DocumentUncheckedCreateWithoutPassengerInput = {
    id?: string
    number?: string | null
    issuanceDate?: string | null
    expiryDate?: string | null
    issuanceCountryCode?: string | null
    issuanceLocation?: string | null
    nationality?: string | null
    documentType?: string | null
    holder?: boolean | null
    birthPlace?: string | null
  }

  export type DocumentCreateOrConnectWithoutPassengerInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPassengerInput, DocumentUncheckedCreateWithoutPassengerInput>
  }

  export type DocumentCreateManyPassengerInputEnvelope = {
    data: Enumerable<DocumentCreateManyPassengerInput>
    skipDuplicates?: boolean
  }

  export type BaggageCreateWithoutPassengerInput = {
    id?: string
    quantity?: number | null
    weight?: string | null
    type?: string | null
  }

  export type BaggageUncheckedCreateWithoutPassengerInput = {
    id?: string
    quantity?: number | null
    weight?: string | null
    type?: string | null
  }

  export type BaggageCreateOrConnectWithoutPassengerInput = {
    where: BaggageWhereUniqueInput
    create: XOR<BaggageCreateWithoutPassengerInput, BaggageUncheckedCreateWithoutPassengerInput>
  }

  export type BaggageCreateManyPassengerInputEnvelope = {
    data: Enumerable<BaggageCreateManyPassengerInput>
    skipDuplicates?: boolean
  }

  export type fareDetailsByRouteCreateWithoutPassengerInput = {
    id?: string
    routeId?: string | null
    fareBasis?: string | null
    class?: string | null
    brandedFare?: string | null
    includedCheckedBagsUnit?: number | null
    includedCheckedBagsWeight?: number | null
    includedCheckedBagsWeightUnit?: string | null
    cabin?: string | null
  }

  export type fareDetailsByRouteUncheckedCreateWithoutPassengerInput = {
    id?: string
    routeId?: string | null
    fareBasis?: string | null
    class?: string | null
    brandedFare?: string | null
    includedCheckedBagsUnit?: number | null
    includedCheckedBagsWeight?: number | null
    includedCheckedBagsWeightUnit?: string | null
    cabin?: string | null
  }

  export type fareDetailsByRouteCreateOrConnectWithoutPassengerInput = {
    where: fareDetailsByRouteWhereUniqueInput
    create: XOR<fareDetailsByRouteCreateWithoutPassengerInput, fareDetailsByRouteUncheckedCreateWithoutPassengerInput>
  }

  export type fareDetailsByRouteCreateManyPassengerInputEnvelope = {
    data: Enumerable<fareDetailsByRouteCreateManyPassengerInput>
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutPassengerInput = {
    update: XOR<BookingUpdateWithoutPassengerInput, BookingUncheckedUpdateWithoutPassengerInput>
    create: XOR<BookingCreateWithoutPassengerInput, BookingUncheckedCreateWithoutPassengerInput>
  }

  export type BookingUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Itinerary?: ItineraryUpdateManyWithoutBookingNestedInput
    Price?: PriceUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Itinerary?: ItineraryUncheckedUpdateManyWithoutBookingNestedInput
    Price?: PriceUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutPassengerInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutPassengerInput, DocumentUncheckedUpdateWithoutPassengerInput>
    create: XOR<DocumentCreateWithoutPassengerInput, DocumentUncheckedCreateWithoutPassengerInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutPassengerInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutPassengerInput, DocumentUncheckedUpdateWithoutPassengerInput>
  }

  export type DocumentUpdateManyWithWhereWithoutPassengerInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    number?: StringNullableFilter | string | null
    issuanceDate?: StringNullableFilter | string | null
    expiryDate?: StringNullableFilter | string | null
    issuanceCountryCode?: StringNullableFilter | string | null
    issuanceLocation?: StringNullableFilter | string | null
    nationality?: StringNullableFilter | string | null
    documentType?: StringNullableFilter | string | null
    passengerId?: StringNullableFilter | string | null
    holder?: BoolNullableFilter | boolean | null
    birthPlace?: StringNullableFilter | string | null
  }

  export type BaggageUpsertWithWhereUniqueWithoutPassengerInput = {
    where: BaggageWhereUniqueInput
    update: XOR<BaggageUpdateWithoutPassengerInput, BaggageUncheckedUpdateWithoutPassengerInput>
    create: XOR<BaggageCreateWithoutPassengerInput, BaggageUncheckedCreateWithoutPassengerInput>
  }

  export type BaggageUpdateWithWhereUniqueWithoutPassengerInput = {
    where: BaggageWhereUniqueInput
    data: XOR<BaggageUpdateWithoutPassengerInput, BaggageUncheckedUpdateWithoutPassengerInput>
  }

  export type BaggageUpdateManyWithWhereWithoutPassengerInput = {
    where: BaggageScalarWhereInput
    data: XOR<BaggageUpdateManyMutationInput, BaggageUncheckedUpdateManyWithoutBaggageInput>
  }

  export type BaggageScalarWhereInput = {
    AND?: Enumerable<BaggageScalarWhereInput>
    OR?: Enumerable<BaggageScalarWhereInput>
    NOT?: Enumerable<BaggageScalarWhereInput>
    id?: StringFilter | string
    quantity?: IntNullableFilter | number | null
    weight?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    passengerId?: StringNullableFilter | string | null
  }

  export type fareDetailsByRouteUpsertWithWhereUniqueWithoutPassengerInput = {
    where: fareDetailsByRouteWhereUniqueInput
    update: XOR<fareDetailsByRouteUpdateWithoutPassengerInput, fareDetailsByRouteUncheckedUpdateWithoutPassengerInput>
    create: XOR<fareDetailsByRouteCreateWithoutPassengerInput, fareDetailsByRouteUncheckedCreateWithoutPassengerInput>
  }

  export type fareDetailsByRouteUpdateWithWhereUniqueWithoutPassengerInput = {
    where: fareDetailsByRouteWhereUniqueInput
    data: XOR<fareDetailsByRouteUpdateWithoutPassengerInput, fareDetailsByRouteUncheckedUpdateWithoutPassengerInput>
  }

  export type fareDetailsByRouteUpdateManyWithWhereWithoutPassengerInput = {
    where: fareDetailsByRouteScalarWhereInput
    data: XOR<fareDetailsByRouteUpdateManyMutationInput, fareDetailsByRouteUncheckedUpdateManyWithoutFareDetailsByRouteInput>
  }

  export type fareDetailsByRouteScalarWhereInput = {
    AND?: Enumerable<fareDetailsByRouteScalarWhereInput>
    OR?: Enumerable<fareDetailsByRouteScalarWhereInput>
    NOT?: Enumerable<fareDetailsByRouteScalarWhereInput>
    id?: StringFilter | string
    routeId?: StringNullableFilter | string | null
    fareBasis?: StringNullableFilter | string | null
    class?: StringNullableFilter | string | null
    brandedFare?: StringNullableFilter | string | null
    includedCheckedBagsUnit?: IntNullableFilter | number | null
    includedCheckedBagsWeight?: IntNullableFilter | number | null
    includedCheckedBagsWeightUnit?: StringNullableFilter | string | null
    cabin?: StringNullableFilter | string | null
    passengerId?: StringNullableFilter | string | null
  }

  export type BookingCreateWithoutItineraryInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Passenger?: PassengerCreateNestedManyWithoutBookingInput
    Price?: PriceCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutItineraryInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Passenger?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    Price?: PriceUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutItineraryInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutItineraryInput, BookingUncheckedCreateWithoutItineraryInput>
  }

  export type RouteCreateWithoutItineraryInput = {
    id?: string
    departIataCode?: string | null
    departTerminal?: string | null
    departAt?: string | null
    arrivalIataCode?: string | null
    arrivalTerminal?: string | null
    arrivalAt?: string | null
    flightNumber?: string | null
    aircraftCode?: string | null
    duration?: string | null
    numberOfStops?: number | null
    carrierCode?: string | null
    routeId?: string | null
  }

  export type RouteUncheckedCreateWithoutItineraryInput = {
    id?: string
    departIataCode?: string | null
    departTerminal?: string | null
    departAt?: string | null
    arrivalIataCode?: string | null
    arrivalTerminal?: string | null
    arrivalAt?: string | null
    flightNumber?: string | null
    aircraftCode?: string | null
    duration?: string | null
    numberOfStops?: number | null
    carrierCode?: string | null
    routeId?: string | null
  }

  export type RouteCreateOrConnectWithoutItineraryInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutItineraryInput, RouteUncheckedCreateWithoutItineraryInput>
  }

  export type RouteCreateManyItineraryInputEnvelope = {
    data: Enumerable<RouteCreateManyItineraryInput>
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutItineraryInput = {
    update: XOR<BookingUpdateWithoutItineraryInput, BookingUncheckedUpdateWithoutItineraryInput>
    create: XOR<BookingCreateWithoutItineraryInput, BookingUncheckedCreateWithoutItineraryInput>
  }

  export type BookingUpdateWithoutItineraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUpdateManyWithoutBookingNestedInput
    Price?: PriceUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutItineraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    Price?: PriceUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type RouteUpsertWithWhereUniqueWithoutItineraryInput = {
    where: RouteWhereUniqueInput
    update: XOR<RouteUpdateWithoutItineraryInput, RouteUncheckedUpdateWithoutItineraryInput>
    create: XOR<RouteCreateWithoutItineraryInput, RouteUncheckedCreateWithoutItineraryInput>
  }

  export type RouteUpdateWithWhereUniqueWithoutItineraryInput = {
    where: RouteWhereUniqueInput
    data: XOR<RouteUpdateWithoutItineraryInput, RouteUncheckedUpdateWithoutItineraryInput>
  }

  export type RouteUpdateManyWithWhereWithoutItineraryInput = {
    where: RouteScalarWhereInput
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyWithoutRouteInput>
  }

  export type RouteScalarWhereInput = {
    AND?: Enumerable<RouteScalarWhereInput>
    OR?: Enumerable<RouteScalarWhereInput>
    NOT?: Enumerable<RouteScalarWhereInput>
    id?: StringFilter | string
    departIataCode?: StringNullableFilter | string | null
    departTerminal?: StringNullableFilter | string | null
    departAt?: StringNullableFilter | string | null
    arrivalIataCode?: StringNullableFilter | string | null
    arrivalTerminal?: StringNullableFilter | string | null
    arrivalAt?: StringNullableFilter | string | null
    flightNumber?: StringNullableFilter | string | null
    aircraftCode?: StringNullableFilter | string | null
    duration?: StringNullableFilter | string | null
    numberOfStops?: IntNullableFilter | number | null
    carrierCode?: StringNullableFilter | string | null
    routeId?: StringNullableFilter | string | null
    itineraryId?: StringNullableFilter | string | null
  }

  export type PassengerCreateWithoutDocumentInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    phone?: string | null
    Booking?: BookingCreateNestedOneWithoutPassengerInput
    Baggage?: BaggageCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteCreateNestedManyWithoutPassengerInput
  }

  export type PassengerUncheckedCreateWithoutDocumentInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    bookingId?: string | null
    phone?: string | null
    Baggage?: BaggageUncheckedCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type PassengerCreateOrConnectWithoutDocumentInput = {
    where: PassengerWhereUniqueInput
    create: XOR<PassengerCreateWithoutDocumentInput, PassengerUncheckedCreateWithoutDocumentInput>
  }

  export type PassengerUpsertWithoutDocumentInput = {
    update: XOR<PassengerUpdateWithoutDocumentInput, PassengerUncheckedUpdateWithoutDocumentInput>
    create: XOR<PassengerCreateWithoutDocumentInput, PassengerUncheckedCreateWithoutDocumentInput>
  }

  export type PassengerUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutPassengerNestedInput
    Baggage?: BaggageUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Baggage?: BaggageUncheckedUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type BookingCreateWithoutPriceInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Passenger?: PassengerCreateNestedManyWithoutBookingInput
    Itinerary?: ItineraryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPriceInput = {
    id?: string
    orderId?: string | null
    orderRef?: string | null
    orderType?: string | null
    status?: string | null
    reference?: string | null
    paymentIntentId?: string | null
    paymentStatus?: string | null
    supplier?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeSessionId?: string | null
    razorpayOrderId?: string | null
    flightOfferId?: string | null
    flightInternalSource?: string | null
    userEmail?: string | null
    Passenger?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    Itinerary?: ItineraryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPriceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPriceInput, BookingUncheckedCreateWithoutPriceInput>
  }

  export type FeeCreateWithoutPriceInput = {
    id?: string
    type?: string | null
    amount?: string | null
    refundable?: string | null
    currency?: string | null
  }

  export type FeeUncheckedCreateWithoutPriceInput = {
    id?: string
    type?: string | null
    amount?: string | null
    refundable?: string | null
    currency?: string | null
  }

  export type FeeCreateOrConnectWithoutPriceInput = {
    where: FeeWhereUniqueInput
    create: XOR<FeeCreateWithoutPriceInput, FeeUncheckedCreateWithoutPriceInput>
  }

  export type FeeCreateManyPriceInputEnvelope = {
    data: Enumerable<FeeCreateManyPriceInput>
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutPriceInput = {
    update: XOR<BookingUpdateWithoutPriceInput, BookingUncheckedUpdateWithoutPriceInput>
    create: XOR<BookingCreateWithoutPriceInput, BookingUncheckedCreateWithoutPriceInput>
  }

  export type BookingUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUpdateManyWithoutBookingNestedInput
    Itinerary?: ItineraryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    orderRef?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    flightOfferId?: NullableStringFieldUpdateOperationsInput | string | null
    flightInternalSource?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Passenger?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    Itinerary?: ItineraryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type FeeUpsertWithWhereUniqueWithoutPriceInput = {
    where: FeeWhereUniqueInput
    update: XOR<FeeUpdateWithoutPriceInput, FeeUncheckedUpdateWithoutPriceInput>
    create: XOR<FeeCreateWithoutPriceInput, FeeUncheckedCreateWithoutPriceInput>
  }

  export type FeeUpdateWithWhereUniqueWithoutPriceInput = {
    where: FeeWhereUniqueInput
    data: XOR<FeeUpdateWithoutPriceInput, FeeUncheckedUpdateWithoutPriceInput>
  }

  export type FeeUpdateManyWithWhereWithoutPriceInput = {
    where: FeeScalarWhereInput
    data: XOR<FeeUpdateManyMutationInput, FeeUncheckedUpdateManyWithoutFeeInput>
  }

  export type FeeScalarWhereInput = {
    AND?: Enumerable<FeeScalarWhereInput>
    OR?: Enumerable<FeeScalarWhereInput>
    NOT?: Enumerable<FeeScalarWhereInput>
    id?: StringFilter | string
    type?: StringNullableFilter | string | null
    amount?: StringNullableFilter | string | null
    refundable?: StringNullableFilter | string | null
    currency?: StringNullableFilter | string | null
    priceId?: StringNullableFilter | string | null
  }

  export type PriceCreateWithoutFeeInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
    Booking?: BookingCreateNestedOneWithoutPriceInput
  }

  export type PriceUncheckedCreateWithoutFeeInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
    bookingId?: string | null
  }

  export type PriceCreateOrConnectWithoutFeeInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutFeeInput, PriceUncheckedCreateWithoutFeeInput>
  }

  export type PriceUpsertWithoutFeeInput = {
    update: XOR<PriceUpdateWithoutFeeInput, PriceUncheckedUpdateWithoutFeeInput>
    create: XOR<PriceCreateWithoutFeeInput, PriceUncheckedCreateWithoutFeeInput>
  }

  export type PriceUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutPriceNestedInput
  }

  export type PriceUncheckedUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerCreateWithoutBaggageInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    phone?: string | null
    Booking?: BookingCreateNestedOneWithoutPassengerInput
    Document?: DocumentCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteCreateNestedManyWithoutPassengerInput
  }

  export type PassengerUncheckedCreateWithoutBaggageInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    bookingId?: string | null
    phone?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutPassengerInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type PassengerCreateOrConnectWithoutBaggageInput = {
    where: PassengerWhereUniqueInput
    create: XOR<PassengerCreateWithoutBaggageInput, PassengerUncheckedCreateWithoutBaggageInput>
  }

  export type PassengerUpsertWithoutBaggageInput = {
    update: XOR<PassengerUpdateWithoutBaggageInput, PassengerUncheckedUpdateWithoutBaggageInput>
    create: XOR<PassengerCreateWithoutBaggageInput, PassengerUncheckedCreateWithoutBaggageInput>
  }

  export type PassengerUpdateWithoutBaggageInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutPassengerNestedInput
    Document?: DocumentUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerUncheckedUpdateWithoutBaggageInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type ItineraryCreateWithoutRouteInput = {
    id?: string
    duration?: string | null
    Booking?: BookingCreateNestedOneWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutRouteInput = {
    id?: string
    duration?: string | null
    bookingId?: string | null
  }

  export type ItineraryCreateOrConnectWithoutRouteInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutRouteInput, ItineraryUncheckedCreateWithoutRouteInput>
  }

  export type ItineraryUpsertWithoutRouteInput = {
    update: XOR<ItineraryUpdateWithoutRouteInput, ItineraryUncheckedUpdateWithoutRouteInput>
    create: XOR<ItineraryCreateWithoutRouteInput, ItineraryUncheckedCreateWithoutRouteInput>
  }

  export type ItineraryUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PassengerCreateWithoutFareDetailsByRouteInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    phone?: string | null
    Booking?: BookingCreateNestedOneWithoutPassengerInput
    Document?: DocumentCreateNestedManyWithoutPassengerInput
    Baggage?: BaggageCreateNestedManyWithoutPassengerInput
  }

  export type PassengerUncheckedCreateWithoutFareDetailsByRouteInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    bookingId?: string | null
    phone?: string | null
    Document?: DocumentUncheckedCreateNestedManyWithoutPassengerInput
    Baggage?: BaggageUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type PassengerCreateOrConnectWithoutFareDetailsByRouteInput = {
    where: PassengerWhereUniqueInput
    create: XOR<PassengerCreateWithoutFareDetailsByRouteInput, PassengerUncheckedCreateWithoutFareDetailsByRouteInput>
  }

  export type PassengerUpsertWithoutFareDetailsByRouteInput = {
    update: XOR<PassengerUpdateWithoutFareDetailsByRouteInput, PassengerUncheckedUpdateWithoutFareDetailsByRouteInput>
    create: XOR<PassengerCreateWithoutFareDetailsByRouteInput, PassengerUncheckedCreateWithoutFareDetailsByRouteInput>
  }

  export type PassengerUpdateWithoutFareDetailsByRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneWithoutPassengerNestedInput
    Document?: DocumentUpdateManyWithoutPassengerNestedInput
    Baggage?: BaggageUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerUncheckedUpdateWithoutFareDetailsByRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutPassengerNestedInput
    Baggage?: BaggageUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerCreateManyBookingInput = {
    id?: string
    passengerId?: string | null
    countryCode?: string | null
    email?: string | null
    dateOfBirth?: string | null
    passengerType?: string | null
    title?: string | null
    gender?: string | null
    firstName?: string | null
    lastName?: string | null
    seatNumber?: string | null
    fareOption?: string | null
    phone?: string | null
  }

  export type ItineraryCreateManyBookingInput = {
    id?: string
    duration?: string | null
  }

  export type PriceCreateManyBookingInput = {
    id?: string
    basePrice?: string | null
    grandTotal?: string | null
    discountAmt?: string | null
    commissionAmt?: string | null
    currency?: string | null
  }

  export type PassengerUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUpdateManyWithoutPassengerNestedInput
    Baggage?: BaggageUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    Document?: DocumentUncheckedUpdateManyWithoutPassengerNestedInput
    Baggage?: BaggageUncheckedUpdateManyWithoutPassengerNestedInput
    fareDetailsByRoute?: fareDetailsByRouteUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type PassengerUncheckedUpdateManyWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    passengerId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    passengerType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    seatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fareOption?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    Route?: RouteUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    Route?: RouteUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutItineraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    Fee?: FeeUpdateManyWithoutPriceNestedInput
  }

  export type PriceUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    Fee?: FeeUncheckedUpdateManyWithoutPriceNestedInput
  }

  export type PriceUncheckedUpdateManyWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmt?: NullableStringFieldUpdateOperationsInput | string | null
    commissionAmt?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyPassengerInput = {
    id?: string
    number?: string | null
    issuanceDate?: string | null
    expiryDate?: string | null
    issuanceCountryCode?: string | null
    issuanceLocation?: string | null
    nationality?: string | null
    documentType?: string | null
    holder?: boolean | null
    birthPlace?: string | null
  }

  export type BaggageCreateManyPassengerInput = {
    id?: string
    quantity?: number | null
    weight?: string | null
    type?: string | null
  }

  export type fareDetailsByRouteCreateManyPassengerInput = {
    id?: string
    routeId?: string | null
    fareBasis?: string | null
    class?: string | null
    brandedFare?: string | null
    includedCheckedBagsUnit?: number | null
    includedCheckedBagsWeight?: number | null
    includedCheckedBagsWeightUnit?: string | null
    cabin?: string | null
  }

  export type DocumentUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceDate?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceLocation?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceDate?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceLocation?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceDate?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    issuanceLocation?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birthPlace?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BaggageUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BaggageUncheckedUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BaggageUncheckedUpdateManyWithoutBaggageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fareDetailsByRouteUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    fareBasis?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    brandedFare?: NullableStringFieldUpdateOperationsInput | string | null
    includedCheckedBagsUnit?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeight?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    cabin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fareDetailsByRouteUncheckedUpdateWithoutPassengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    fareBasis?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    brandedFare?: NullableStringFieldUpdateOperationsInput | string | null
    includedCheckedBagsUnit?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeight?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    cabin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fareDetailsByRouteUncheckedUpdateManyWithoutFareDetailsByRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    fareBasis?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    brandedFare?: NullableStringFieldUpdateOperationsInput | string | null
    includedCheckedBagsUnit?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeight?: NullableIntFieldUpdateOperationsInput | number | null
    includedCheckedBagsWeightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    cabin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteCreateManyItineraryInput = {
    id?: string
    departIataCode?: string | null
    departTerminal?: string | null
    departAt?: string | null
    arrivalIataCode?: string | null
    arrivalTerminal?: string | null
    arrivalAt?: string | null
    flightNumber?: string | null
    aircraftCode?: string | null
    duration?: string | null
    numberOfStops?: number | null
    carrierCode?: string | null
    routeId?: string | null
  }

  export type RouteUpdateWithoutItineraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    departIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    departTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    departAt?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalAt?: NullableStringFieldUpdateOperationsInput | string | null
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aircraftCode?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfStops?: NullableIntFieldUpdateOperationsInput | number | null
    carrierCode?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteUncheckedUpdateWithoutItineraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    departIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    departTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    departAt?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalAt?: NullableStringFieldUpdateOperationsInput | string | null
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aircraftCode?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfStops?: NullableIntFieldUpdateOperationsInput | number | null
    carrierCode?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    departIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    departTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    departAt?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalIataCode?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTerminal?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalAt?: NullableStringFieldUpdateOperationsInput | string | null
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aircraftCode?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfStops?: NullableIntFieldUpdateOperationsInput | number | null
    carrierCode?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeCreateManyPriceInput = {
    id?: string
    type?: string | null
    amount?: string | null
    refundable?: string | null
    currency?: string | null
  }

  export type FeeUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    refundable?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    refundable?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeUncheckedUpdateManyWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    refundable?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}